#+HUGO_BASE_DIR: ../
#+MACRO: more @@html:<!--more-->@@
#+MACRO: twitter [[https://twitter.com/$1][@$1]]
#+MACRO: github [[https://github.com/$1/$2][$2]]

* blog
:PROPERTIES:
:EXPORT_HUGO_SECTION: post
:END:
** リポジトリのデプロイキーを使ってTravis CIからGitHubにプッシュする     :CI:
:PROPERTIES:
:EXPORT_FILE_NAME: 2019-03-02-push-to-github-from-travis-with-deploy-key
:EXPORT_DATE: 2019-03-02
:EXPORT_HUGO_LASTMOD:
:END:

CIで静的サイトを生成している場合、生成した静的サイトをリポジトリにコミット＆プッシュしたいことがよくあります。そのためにはCIからリポジトリへのプッシュ権限が必要になります。例えばTravis CIからGitHubにコミットをプッシュする場合は、GitHubのアクセストークンをHTTPSのBasic認証で送信するのがよくあるパターンです。

wip

{{{more}}}
*** 鍵生成、登録

- 鍵ペア生成
- デプロイキー登録
- 秘密鍵暗号化
- 秘密鍵を使ってプッシュ

ECDSA384ビットの鍵ペアを生成する。

#+BEGIN_SRC console
> ssh-keygen -t ecdsa -b 384 -C travis@travis-ci.org -f www_deploy_key_by_travis
Generating public/private ecdsa key pair.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in www_deploy_key_by_travis.
Your public key has been saved in www_deploy_key_by_travis.pub.
The key fingerprint is:
SHA256:JmxNDpRgGGaJYWUapfvBbnfyCpx4CCPsUOR/vGvAS8U travis@travis-ci.org
The key's randomart image is:
+---[ECDSA 384]---+
|.=BBo...         |
|o=B. ..          |
| oo  .. .        |
|..o. oE=         |
|=o +..* S        |
|=.* *o +         |
| + X =..         |
|  o + =.         |
|     oo.         |
+----[SHA256]-----+
#+END_SRC

秘密鍵 ~www_deploy_key_by_travis~ と公開鍵 ~www_deploy_key_by_travis.pub~ が生成される。公開鍵の内容をGitHubのリポジトリのDeploy Keyとしてコピペする。

[[file:/images/writable_key_by_traviskeyboard.png]]

~Title~ はわかりやすい適当な名前にする。これで公開鍵は用済みなので削除していい。

次に ~travis encrypt-file~ コマンドで秘密鍵を暗号化する。下記ではDockerコンテナ内で実行する。

#+begin_src console
> docker run --rm -it -v %CD%:/mnt -w /mnt ruby bash
# gem install travis
# travis login --com
Shell completion not installed. Would you like to install it now? |y| n
We need your GitHub login to identify you.
This information will not be sent to Travis CI, only to api.github.com.
The password will not be displayed.

Try running with --github-token or --auto if you don't want to enter your password anyway.

Username: kai2nenobu
Password for kai2nenobu: ************
Successfully logged in as kai2nenobu!
# travis encrypt-file --com www_deploy_key_by_travis
encrypting www_deploy_key_by_travis for kai2nenobu/www
storing result as www_deploy_key_by_travis.enc
storing secure env variables for decryption

Please add the following to your build script (before_install stage in your .travis.yml, for instance):

    openssl aes-256-cbc -K $encrypted_c546895bd2a4_key -iv $encrypted_c546895bd2a4_iv -in www_deploy_key_by_travis.enc -out www_deploy_key_by_travis -d

Pro Tip: You can add it automatically by running with --add.

Make sure to add www_deploy_key_by_travis.enc to the git repository.
Make sure not to add www_deploy_key_by_travis to the git repository.
Commit all changes to your .travis.yml.
# exit
> rm www_deploy_key_by_travis
> echo www_deploy_key_by_travis >> .gitignore
> git add www_deploy_key_by_travis.enc .gitignore
> git commit -m "暗号化した秘密鍵を追加する"
#+end_src


#+begin_src sh
## pushにsshを使う
$ git config url."git@github.com".pushInsteadOf "https://github.com/"
$ export GIT_SSH_COMMAND="ssh -i file"
$ openssl aes-256-cbc -K $encrypted_c546895bd2a4_key -iv $encrypted_c546895bd2a4_iv -in www_deploy_key_by_travis.enc -out www_deploy_key_by_travis -d
#+end_src
*** 参考URL
- [[https://docs.travis-ci.com/user/encrypting-files/][Encrypting Files - Travis CI]]
- [[https://efcl.info/2016/09/27/deploy-from-travis-ci-to-gh-pages/][Travis CIからgh-pagesへデプロイする設定 via SSH/git push | Web Scratch]]
- [[https://discuss.bitrise.io/t/git-force-to-use-ssh-url-instead-of-https-for-github-com/4384][Git: force to use SSH URL instead of HTTPS for github.com]]
** Emacs Lispで「ソフトウェアエンジニアならば1時間（略）」を解いてみた 二番煎じ :Emacs:
:PROPERTIES:
:EXPORT_FILE_NAME: 2015-05-31-five-programming-problems-every-software-engineer-should-be-able-to-solve-in-less-than-1-hour
:EXPORT_DATE: 2015-05-31
:EXPORT_HUGO_LASTMOD:
:END:

[[http://d.hatena.ne.jp/syohex/touch/20150529/1432908287][Emacs Lispで「ソフトウェアエンジニアならば1時間以内に解けなければいけない5つの問題」を解いてみた - Life is very short]]という記事を見かけて、面白そうだったので自分でも解いてみました。二番煎じです。

上記事では =(require 'cl-lib)= してcl系マクロを使ってやってるみたいだったので、cl-libなし縛りでやってみました。

- 発端 [[https://blog.svpino.com/2015/05/07/five-programming-problems-every-software-engineer-should-be-able-to-solve-in-less-than-1-hour][Five programming problems every Software Engineer should be able to solve in less than 1 hour]]

{{{more}}}
*** 問題1
#+BEGIN_SRC emacs-lisp
;; Write three functions that compute the sum of the numbers in a given list
;; using a for-loop, a while-loop, and recursion.
(defun for-sum (lst)
  (let ((sum 0))
    (dolist (elm lst sum)
      (setq sum (+ sum elm)))))
(for-sum '(-1 0 1 2))                   ; => 2

(defun while-sum (lst)
  (let ((sum 0))
    (while lst
      (setq sum (+ sum (car lst)))
      (setq lst (cdr lst)))
    sum))
(while-sum '(-1 0 1 2))                 ; => 2

(defun recursive-sum (lst)
  (if (null lst)
      0
    (+ (car lst) (recursive-sum (cdr lst)))))
(recursive-sum '(-1 0 1 2))             ; => 2
#+END_SRC
*** 問題2
#+BEGIN_SRC emacs-lisp
;; Write a function that combines two lists by alternatingly taking
;; elements. For example: given the two lists [a, b, c] and [1, 2, 3], the
;; function should return [a, 1, b, 2, c, 3].
(defun alternate-cat (lst1 lst2)
  (let ((min-length (min (length lst1) (length lst2)))
        combined)
    (dotimes (i min-length)
      (push (nth i lst1) combined)
      (push (nth i lst2) combined))
    ;; append a rest of longer list
    (append (reverse combined)
            (nthcdr min-length
                    (if (< (length lst1) (length lst2)) lst2 lst1)))))
(alternate-cat '(a b c) '(1 2 3))       ; => (a 1 b 2 c 3)
(alternate-cat '(a b c d e f) '(1 2 3)) ; => (a 1 b 2 c 3 d e f)
(alternate-cat '(a b c) '(1 2 3 4 5))   ; => (a 1 b 2 c 3 4 5)
#+END_SRC
問題5で再利用する都合上、2つのリストの長さが異なる場合は、長いリストの残りの部分を末尾に並べるようにしました。

cl-loopマクロがないと、複数のリストを同時にループさせるのが辛い。
*** 問題3
#+BEGIN_SRC emacs-lisp
;; Write a function that computes the list of the first 100 Fibonacci
;; numbers. By definition, the first two numbers in the Fibonacci sequence
;; are 0 and 1, and each subsequent number is the sum of the previous two. As
;; an example, here are the first 10 Fibonnaci numbers: 0, 1, 1, 2, 3, 5, 8,
;; 13, 21, and 34.
(require 'calc)
(defun fibonacci-list (n)
  (let (fib-list)
    (dotimes (i n)
      (if (memql i '(0 1))
          (push i fib-list)
        (push (math-add (car fib-list) (cadr fib-list)) fib-list)))
    ;; Convert to string for printing
    (mapcar #'math-format-number (reverse fib-list))))
(fibonacci-list 100)                     ; => ("0" "1" "1" "2" "3" "5" "8" "13" "21" "34" "55" "89" "144" "233" "377" "610" "987" "1597" "2584" "4181" "6765" "10946" "17711" "28657" "46368" "75025" "121393" "196418" "317811" "514229" "832040" "1346269" "2178309" "3524578" "5702887" "9227465" "14930352" "24157817" "39088169" "63245986" "102334155" "165580141" "267914296" "433494437" "701408733" "1134903170" "1836311903" "2971215073" "4807526976" "7778742049" "12586269025" "20365011074" "32951280099" "53316291173" "86267571272" "139583862445" "225851433717" "365435296162" "591286729879" "956722026041" "1548008755920" "2504730781961" "4052739537881" "6557470319842" "10610209857723" "17167680177565" "27777890035288" "44945570212853" "72723460248141" "117669030460994" "190392490709135" "308061521170129" "498454011879264" "806515533049393" "1304969544928657" "2111485077978050" "3416454622906707" "5527939700884757" "8944394323791464" "14472334024676221" "23416728348467685" "37889062373143906" "61305790721611591" "99194853094755497" "160500643816367088" "259695496911122585" "420196140727489673" "679891637638612258" "1100087778366101931" "1779979416004714189" "2880067194370816120" "4660046610375530309" "7540113804746346429" "12200160415121876738" "19740274219868223167" "31940434634990099905" "51680708854858323072" "83621143489848422977" "135301852344706746049" "218922995834555169026")
#+END_SRC
フィボナッチ数列の100番目は =218922995834555169026= なわけですが、Emacs Lispの整数上限を軽く超えています。なので上記事と同様 =calc.el= を使って任意桁整数を扱えるようにしています。

この問題はフィボナッチ数列の計算ではなく、任意桁整数の扱い方を確認する意図があるのかな、という気がしました。
*** 問題4
#+BEGIN_SRC emacs-lisp
;; Write a function that given a list of non negative integers, arranges them
;; such that they form the largest possible number. For example, given [50,
;; 2, 1, 9], the largest formed number is 95021.
(defun largest-combined-number (lst)
  (string-to-number
   (mapconcat #'identity
              ;; sort descending dictionary order
              (sort (mapcar #'number-to-string lst)
                    (lambda (elm1 elm2) (string< elm2 elm1)))
              "")))
(largest-combined-number '(50 2 1 9))   ; => 95021
#+END_SRC
辞書順にソートするのを思いつけばすぐ解けました。
*** 問題5
#+BEGIN_SRC emacs-lisp
;; Write a program that outputs all possibilities to put + or - or nothing
;; between the numbers 1, 2, ..., 9 (in this order) such that the result is
;; always 100. For example: 1 + 2 + 34 – 5 + 67 – 8 + 9 = 100.
(defun output-all-expressions (expected)
  (let* ((numbers (mapcar #'number-to-string (number-sequence 1 9)))
         (ops '("+" "-" ""))
         ;; all permutations of binary operators
         (ops-permutations (list-permutations ops (1- (length numbers)))))
    (dolist (ops-perm ops-permutations)
      (let (;; insert ops between numbers
            (expression (mapconcat #'identity                         ; (ref:1)
                                   (alternate-cat numbers ops-perm)
                                   ""))
            (start 0)
            lst)
        ;; separate the expression into a list of numbers
        (while (string-match "[-+]?[0-9]+" expression start)
          (push (string-to-number (match-string 0 expression)) lst)
          (setq start (match-end 0)))
        (when (= (for-sum lst) expected)
          (insert (format "%s=%s\n" expression expected)))
        ))))

(defun list-permutations (lst n)
  (if (< n 1)
      nil
    (if (= n 1)
        (mapcar #'list lst)
      (let (result)
        (dolist (elm lst result)
          (setq result (append result
                               (mapcar (lambda (x) (cons elm x))
                                       (list-permutations lst (1- n)))))))
      )))
#+END_SRC
=(output-all-expressions 100)= を評価すると以下のように出力されます。たしかに =1 + 2 + 34 – 5 + 67 - 8 + 9 = 100= が含まれています。
#+BEGIN_EXAMPLE
1+2+3-4+5+6+78+9=100
1+2+34-5+67-8+9=100
1+23-4+5+6+78-9=100
1+23-4+56+7+8+9=100
12+3+4+5-6-7+89=100
12+3-4+5+67+8+9=100
12-3-4+5-6+7+89=100
123+4-5+67-89=100
123+45-67+8-9=100
123-4-5-6-7+8-9=100
123-45-67+89=100
#+END_EXAMPLE

問題1と問題2の関数を再利用しています。

なんとなく演算子の順列を全部試せばいいんだろうな、とは思いついたものの順列組み合わせを算出する関数(=list-permutations=)を書くのにかなり時間がかかりました。関数プログラミング的なリスト操作関数を自分で実装するというのに慣れてなくて大変手間取りました。

また数値と演算子のリストからどうやって結果を算出するかも悩ましいところでした。リストを何とかしてポーランド式とか逆ポーランド式の木構造に加工すればいいのか、など考えたもののcl-libが使えないのではそれもままならなさそうだと感じられた。なのでまず数式を文字列で作ってしまって、それを前からパースする単純な方法にしました。
*** 感想
問題1〜4で1時間かかって、5でさらに1時間ぐらいかかりました。残念ながらソフトウェアエンジニア失格。

cl-libを使わなかったのでループが辛いのもさることながら、cl-labelsとかcl-fletなどの一時的な関数定義が使えないのが可読性の低さに拍車をかけている気がします。またリスト操作関数がmapcarぐらいしかないのがEmacs Lispの辛いところ。

またLispの常ですが、処理の順番とコードの順番が一致しないので、処理内容を把握するのにひと手間かかります。これを解消するには[[https://github.com/magnars/dash.el][dash.el]]のスレッディングマクロをぜひ使いたいところです。折しもつい最近[[http://rubikitch.com/2015/05/30/dash-threading-macro/][るびきちさんが紹介しています]]。

例えば問題4をdash（とs）を使って書き換えると以下のようになります。
#+BEGIN_SRC emacs-lisp
(require 'dash)
(require 's)
(defun largest-combined-number2 (lst)
  (->> lst                              ; リストの
       (-map #'number-to-string)        ; 各要素を文字列に変換して
       (--sort (string< other it))      ; 逆順にソートして
       (s-join "")                      ; 結合して
       (string-to-number)))             ; 数値に変換する
(largest-combined-number2 '(50 2 1 9))  ; => 95021
#+END_SRC
上から下に読んでいけばそのまま処理を追っていけるので、可読性が抜群に高いです。豊富なリスト操作関数も含めて、dashおすすめです。
**** 結論
cl-libやdashを積極的に使っていきましょう。

** Java8をemacs-quickrunでコンパイルする                         :Emacs:Java:
:PROPERTIES:
:EXPORT_FILE_NAME: 2014-03-22-emacs-java-quickrun
:EXPORT_DATE: 2014-03-22
:EXPORT_HUGO_LASTMOD:
:END:

EmacsのquickrunでJavaを動かすというニッチな人向けです。

{{{more}}}
*** Java8を入れてみた
[[https://blogs.oracle.com/java/entry/java_se_8_is_now][Java SE 8]]が先日リリースされたので試しに使ってみることにしました。普段のコンパ
イラはJava7のままにしたかったので、Java8の ~javac~ と ~java~ は ~javac8~ と
~java8~ というシンボリックリンクを作って利用することにしました。

これをEmacsの[[https://github.com/syohex/emacs-quickrun][quickrun]]でコンパイル＆実行したいので、マニュアル通り
#+BEGIN_SRC emacs-lisp
(quickrun-add-command  "java8"
                       '((:command . "java8")
                         (:compile-only . "javac8 -Werror %o %s")
                         (:exec    . ("javac8 %o %s" "%c %N %a"))
                         (:cmdopt . "-encoding UTF-8")
                         (:remove  . ("%n.class"))
                         (:description . "Compile Java8 file and execute")))
#+END_SRC
として、Java8用の "java8" というコマンドを追加しました。

これでquickrunを実行してみると
#+BEGIN_EXAMPLE
qr_65243Cj.java:4: エラー: クラスHogeはpublicであり、ファイルHoge.javaで宣言する必要があります
public class Hoge {
       ^
エラー1個
#+END_EXAMPLE
とか怒られました。そういえばquickrunは一時ファイルを作ってそれをコンパイルする
はずなので、ファイル名とクラス名が一致しなくて怒られる。

でも既存のJavaであればquickrunを利用できるはずだけどな？ と思ってquickrunのソー
スを読むとJavaとGoだけは一時ファイルを利用しないらしい。
#+BEGIN_SRC emacs-lisp
(defsubst quickrun/use-tempfile-p (cmd-key)
  (not (or (member cmd-key '("java" "go/go")) quickrun/compile-only-flag)))
#+END_SRC

なのでこの関数をアドバイスすることにした。
#+BEGIN_SRC emacs-lisp
(defadvice quickrun/use-tempfile-p (after java8 activate)
  "Java8でも一時ファイルを作らないようアドバイス"
  (when (string= (ad-get-arg 0) "java8")
    (setq ad-return-value nil)))
#+END_SRC
これで無事コンパイル＆実行できました。無理やりだけどいいことにしよう。

** Emacs Lispのテスト、依存性管理、CI                            :Emacs:Test:
:PROPERTIES:
:EXPORT_FILE_NAME: 2014-02-23-emacs-cask
:EXPORT_DATE: 2014-02-23
:EXPORT_HUGO_LASTMOD:
:END:

現在開発中の[[https://github.com/kbkbkbkb1/guide-key][guide-key]]の機能がそれなりに増えてきたので、そろそろテストを書きた
いなと思いました。そこでERTでユニットテストを書いて、Caskで依存関係を解決して、
Travis CIでCIするところまでできたので紹介します。

{{{more}}}

*** ERTでユニットテスト
[[http://www.emacswiki.org/emacs/ErtTestLibrary][ERT]]はEmacs Lisp Regression Testingの略で、Emacs Lispのテスティングツールです。
JUnitなどと同様にユニットテストが書けます。
**** ディレクトリ構成
- [[http://d.hatena.ne.jp/pogin/20130617/1371488876][EmacsLispで最小構成(っぽい)テストをする方法 - プログラムとかののblog]]
が丁度良くテストの最小構成を紹介していたので、真似して以下のようなディレクトリ
構成にしました。
#+BEGIN_EXAMPLE
guide-key/
├── guide-key.el
└── test/
    └── guide-key-test.el
#+END_EXAMPLE
参考にしたリポジトリも、概ねリポジトリ直下に ~test~ などのテスト専用のディレ
クトリを配置しているのが多かったです。
**** テストを書いて実行
テストの書き方の詳細は[[http://www.gnu.org/software/emacs/manual/ert.html][マニュアル]]に譲りますが、 ~ert-deftest~ でテストケースを
定義し、 ~should~ でアサーションすることができます。とりあえず最近追加した関数
のテストを書いてみました。
#+BEGIN_SRC emacs-lisp
(require 'ert)
(require 'guide-key)
(eval-when-compile
  (require 'cl))

(ert-deftest guide-key-test/get-highlight-face ()
  "Test of `guide-key/get-highlight-face'"
  (let ((guide-key/highlight-command-regexp
         '("rectangle"
           ("register" . font-lock-type-face)
           ("bookmark" . font-lock-warning-face)
           ))
        (fixtures
         '(("Prefix Command" . guide-key/prefix-command-face)
           ("string-rectangle" . guide-key/highlight-command-face)
           ("jump-to-register" . font-lock-type-face)
           ("bookmark-jump" . font-lock-warning-face)
           ("copy-rectangle-to-register" . guide-key/highlight-command-face)
           ("<NOTEXIST>" . nil)
           ))
        actual)
    (loop for (input . expected) in fixtures
          do
          (setq actual (guide-key/get-highlight-face input))
          (should (eq actual expected)))
    ))
#+END_SRC

まだテストの前処理、後処理やテストケースの構造化をする方法がよくわからないの
で、識者の意見がほしいです。

テストの実行するにはEmacs内から ~ert~ コマンドを実行するか、以下のようにコマン
ドラインからEmacsのバッチを呼び出します。
#+BEGIN_EXAMPLE
$ emacs -batch -l test/guide-key-test.el -f ert-run-tests-batch-and-exit
#+END_EXAMPLE

しかしguide-keyは[[https://github.com/m2ym/popwin-el][popwin]]に依存しているため、このコマンドだけではテストが実行で
きません。popwinのあるところに ~load-path~ を通す必要があります。これを手動で
やるのは大変なので、Caskという依存関係を解決してくれるツールを利用することにし
ました。
*** Caskで依存関係管理
[[https://github.com/cask/cask][Cask]]はEmacsの依存関係管理ツールです。標準添付のpackage.elもライブラリの依存関
係を考慮して必要ライブラリを一括でダウンロードすることはできます。しかし 個人
の設定のために =~/.emacs.d= にダウンロードする前提なので、ライブラリの開発で
利用するのには向きません。

CaskはRubyでいうGemfileのように、Caskファイルに依存しているライブラリを記述す
ることで、一括ダウンロードや ~PATH~ 、 ~load-path~ の調整をしてくれます。
**** インストール
#+BEGIN_EXAMPLE
$ curl -fsSkL https://raw.github.com/cask/cask/master/go | python
$ export PATH="$HOME/.cask/bin:$PATH"
#+END_EXAMPLE
だけです。

ちなみにWindowsで試してみたら、うまくインストール出来ませんでした。Cygwinなの
が悪いのでしょうか。
**** 依存関係の解決
リポジトリの直下の ~Cask~ ファイルに、依存しているライブラリを記述します。例え
ばこのような感じです。
#+BEGIN_SRC emacs-lisp
(source gnu)
(source melpa)
(source marmalade)

(package-file "guide-key.el")

(development
 (depends-on "ert")
 (depends-on "popwin"))
#+END_SRC
~source~ がライブラリを参照する場所、 ~package-file~ が開発しているライブラリ、
~depends-on~ が依存しているライブラリです。詳しくは[[http://cask.github.io/usage/][Usage]]を見てください。
guide-key自身が依存しているのはpopwinだけですが、Emacs23でテストする際にertが
必要になるのでertも依存ライブラリとしています。

実際に依存ライブラリをダウンロードするには、コマンドラインで ~cask~ あるいは
~cask install~ します。
#+BEGIN_EXAMPLE
$ cask install
Contacting host: marmalade-repo.org:80
Saving file /home/kai/.emacs.d/my-lisp/guide-key/.cask/24.3.1/elpa/archives/marmalade/archive-contents...
（中略）
Wrote /home/kai/.emacs.d/my-lisp/guide-key/.cask/24.3.1/elpa/popwin-20130329.435/popwin.elc
Done (Total of 2 files compiled, 1 skipped)
$ ls .cask/24.3.1/elpa/
archives  popwin-20130329.435
#+END_EXAMPLE
これで ~.cask~ ディレクトリが作成され、依存ライブラリがダウンロードされます。

この状態で
#+BEGIN_EXAMPLE
$ cask exec command
#+END_EXAMPLE
することで、 ~.cask~ 以下にある依存ライブラリを ~PATH~ や ~load-path~ に追加し
た状態で ~command~ を実行することができます。したがって以下のコマンドでテスト
を実行することができます。
#+BEGIN_EXAMPLE
$ cask exec emacs -batch -L . -l test/guide-key-test.el -f ert-run-tests-batch-and-exit
Running 1 tests (2014-02-23 12:56:40+0900)
   passed  1/1  guide-key-test/get-highlight-face

Ran 1 tests, 1 results as expected (2014-02-23 12:56:40+0900)
#+END_EXAMPLE
無事テストが成功しました。

Caskを使えばpopwinへの ~load-path~ を考える必要がないのが楽です。ただしCaskは
リポジトリ直下（guide-key.elがあるディレクトリ）を ~load-path~ に追加してくれ
ないようなので、 ~-L .~ で手動で追加しています。あまり美しい方法では無いですね。
参考にしたリポジトリでは、 ~test/test-init.el~ などのテスト初期化ファイルを作っ
て、そこで開発ライブラリ（guide-key.el）をロードするような構成になっているもの
もありました。
**** 環境変数で環境を切り替える
環境変数 ~EMACS~ を設定することで、Caskで利用するEmacsを切り替えることができま
す。上の ~emacs~ はバージョンが24でしたが、それとは別にバージョン23の
~emacs23~ がインストールされている場合、以下のように ~cask~ を環境変数を変更し
て実行します。
#+BEGIN_EXAMPLE
$ export EMACS=emacs23
$ cask install
Contacting host: marmalade-repo.org:80
Saving file /home/kai/.emacs.d/my-lisp/guide-key/.cask/23.3.1/elpa/archives/marmalade/archive-contents...
（中略）
Wrote /home/kai/.emacs.d/my-lisp/guide-key/.cask/23.3.1/elpa/popwin-20130329.435/popwin.elc
Done (Total of 2 files compiled, 1 skipped)
$ ls .cask/23.3.1/elpa
archives  ert-0  popwin-20130329.435
#+END_EXAMPLE

あとは先ほどと同様に
#+BEGIN_EXAMPLE
$ cask exec ${EMACS} -batch -L . -l test/guide-key-test.el -f ert-run-tests-batch-and-exit
Running 1 tests (2014-02-23 12:56:40+0900)
   passed  1/1  guide-key-test/get-highlight-face

Ran 1 tests, 1 results as expected (2014-02-23 12:56:40+0900)
#+END_EXAMPLE
でテストが回せます。popwinやertへの ~load-path~ を考える必要がなく、同じコマン
ドなのがいいですね。
*** Travis CIでCI
テストが書けたのでCIできるように[[http://docs.travis-ci.com/user/getting-started/][Travis CI]]を利用します。
**** Makefileで自動化
~make~ コマンド一発でテストを回すために、Makefileを作ります。
#+BEGIN_SRC makefile-gmake
EMACS ?= emacs
CASK ?= cask

all:
	${MAKE} clean
	${MAKE} test
	${MAKE} compile
	${MAKE} test
	${MAKE} clean

compile:
	# Fail if byte-compile outpus warnings
	${CASK} exec ${EMACS} -batch -Q -L . -eval \
	"(progn \
	(setq byte-compile-error-on-warn t) \
	(batch-byte-compile))" guide-key.el
test:
	${CASK} exec ${EMACS} -Q -batch -L . -l test/guide-key-test.el -f ert-run-tests-batch-and-exit
clean:
	rm -f guide-key.elc

.PHONY: all compile test clean
#+END_SRC
簡単なMakefileですが ~make~ コマンドでバイトコンパイルせずにテストと、バイトコ
ンパイルしてテストを実行します。バイトコンパイルで警告が出ると失敗させているの
は厳しすぎるかもしれませんが、当面これで行くことにしました。
**** Travisの設定
Travisのビルド設定をtravis.ymlに書きます。
#+BEGIN_SRC yaml
language: emacs-lisp
env:
  - EMACS=emacs23
  - EMACS=emacs24
  - EMACS=emacs-snapshot
matrix:
  allow_failures:
    - env: EMACS=emacs-snapshot
before_install:
  # Install Emacs
  - sudo add-apt-repository -y ppa:cassou/emacs
  - sudo apt-get update -qq
  - sudo apt-get install -qq $EMACS
  # Install Cask
  - curl -fsSkL --max-time 10 --retry 10 --retry-delay 10
        https://raw.github.com/cask/cask/master/go | python
  - export PATH="$HOME/.cask/bin:$PATH"
  - cask
script:
  make
#+END_SRC
~before_install~ で必要なEmacsとCaskをインストールして、テストを回します。テス
ト環境は ~emacs23~ と ~emacs24~ と ~emacs-snapshot~ の3つとし、環境変数
~EMACS~ を設定することで自動的に ~cask~ の動作が変わるようになります。

実際にビルドした結果が以下のようになります。

#+ATTR_HTML: :title Travis CIへGo :alt guide-keyのTravis CIでのビルド結果
[[https://travis-ci.org/kbkbkbkb1/guide-key][file:/images/guide-key-travis-ci.png]]

~emacs-snapshot~ がなぜか失敗しているので、やむを得ず ~allow_failures~ に入れ
てます。
*** まとめ
Emacs Lispのテスト、依存性管理、CIする方法を紹介しました。最終的なディレクトリ
構成は以下のようになりました。
#+BEGIN_EXAMPLE
guide-key/
├── .cask/          # 依存ライブラリを格納
│   ├── 23.3.1/      # Emacsのバージョン別に保持
│   ├── 24.3.1/
│   └── ...
├── .travis.yml     # Travis CIの設定
├── Cask            # 依存ライブラリを記述
├── Makefile        # テストの自動化
├── guide-key.el
└── test/
    └── guide-key-test.el
#+END_EXAMPLE

あとはテストケースが全然不十分なので、テストケースを充実させていくだけです。
guide-keyは副作用がある関数ばかりなので、テストが書きにくそうです。できるだけ
副作用のない粗結合の構成になるようにリファクタリングしたいと思います。

さらにテストを便利にするためのライブラリとして、[[https://github.com/rejeep/ert-runner.el][rejeep/ert-runner.el]]や
[[https://github.com/ecukes/ecukes][ecukes/ecukes]]があります。ert-runnerはJUnitでいうテストスイートのようなもので、
テスト名やタグによって実行するテストケースを制御するライブラリです。ecukesは
cucumberのように振る舞い駆動開発するためのライブラリのようです。

これらもおいおい導入していければと思います。
**** 参考にしたリポジトリ
- Caskを作っている[[https://github.com/rejeep][rejeep (Johan Andersson)]]さんのリポジトリ
  - [[https://github.com/cask/cask][cask/cask]]
  - [[https://github.com/ecukes/ecukes][ecukes/ecukes]]
  - [[https://github.com/rejeep/ert-runner.el][rejeep/ert-runner.el]]
  - [[https://github.com/rejeep/f.el][rejeep/f.el]]
- テストを作る際のテンプレート
  - [[https://github.com/pogin503/emacs-test-sample][pogin503/emacs-test-sample]] ERTでテストする最小構成。
  - [[https://github.com/lewang/ert-test-skeleton][lewang/ert-test-skeleton]] Travis CIを利用するテンプレート（Caskなし）。
  - [[https://github.com/tkf/emacs-plugin-template][tkf/emacs-plugin-template]] CaskとTravis CIを利用したテンプレート。Caskの旧
    名のCartonが使われているが、Caskでもほぼそのまま利用できる。

** guide-keyの新機能棚卸                                    :Emacs:guide_key:
:PROPERTIES:
:EXPORT_FILE_NAME: 2013-12-22-emacs-advent-calendar-2013-22
:EXPORT_DATE: 2013-12-22
:EXPORT_HUGO_LASTMOD:
:END:

この記事は[[http://qiita.com/advent-calendar/2013/dot-emacs][.emacs Advent Calendar 2013]]の22日目の記事です。
[[./2012-12-03-emacs-advent-calendar-2012-03.org][去年のアドベントカレンダー]]で[[https://github.com/kbkbkbkb1/guide-key/blob/master/README.ja.org][guide-key]]という、キーバインドを自動表示する自作ラ
イブラリを紹介しました。この1年でいくつか機能を追加したので改めて紹介します。

{{{more}}}
*** 基本的な使い方
基本的な使い方は[[./2012-12-03-emacs-advent-calendar-2012-03.org][去年のアドベントカレンダー]]の頃と変わってません。guide-keyは
MELPAに登録してあるので、 =M-x package-install guide-key= でインストールしてく
ださい。

=guide-key/guide-key-sequence= にポップアップして欲しいプレフィクスキーを登録
します。init.elに以下のように設定してください。
#+BEGIN_SRC emacs-lisp
(require 'guide-key)
(setq guide-key/guide-key-sequence '("C-x r" "C-x 4"))
(guide-key-mode 1)  ; guide-key-mode を有効にする
#+END_SRC
これで =C-x r= や =C-x 4= のプレフィクスキーを押した時に、次に続くキーバインド
を表示するウィンドウが自動的にポップアップされます。実際に =C-x r= に押した様
子は以下のようになります。

[[file:/images/guide-key-example.png]]
*** 追加機能
**** ポップアップウィンドウの表示遅延
=guide-key/idle-delay= でポップアップウィンドウが表示されるまでの時間を調整で
きるようになりました。以前は入力されているキーをポーリングでチェックしていたの
で、プレフィクスキーを押してからポップアップウィンドウが表示されるまでの時間が
一定ではありませんでした。

=guide-key/idle-delay= はデフォルトで1秒になっているので、自分の好みに合わせて
調整してください。すでに覚えているキーバインドを素早く入力すればウィンドウはポッ
プアップされませんし、キーバインドを覚えておらず入力が途中で止まった時は
=guide-key/idle-delay= 秒後にウィンドウがポップアップされます。
**** 特定のモードに関する設定
=guide-key/guide-key-sequence= に、特定のモードでのみポップアップしたいプレフィ
クスキーを設定できるようになりました。例えば以下のように設定してください。
#+BEGIN_SRC emacs-lisp
(setq guide-key/guide-key-sequence
      '("C-x r" "C-x 4"                  ; すべてのバッファで有効
        (org-mode "C-c C-x")             ; org-modeのバッファのみ
        (outline-minor-mode "C-c @")     ; outline-minor-modeのバッファのみ
        ))
#+END_SRC
メジャーモードが =org-mode= の場合 =C-c C-x= に続くキーバインドがポップアップ
されます。 =outline-minor-mode= が有効な場合、 =C-c @= に続くキーバインドがポッ
プアップされます。
**** プレフィクスキーの再帰的なチェック
=guide-key/recursive-key-sequence-flag= がnon-nilの時、guide-keyは入力されたキー
を再帰的にチェックします。つまり =C-x 8 ^= が入力されている時、guide-keyは
=guide-key/guide-key-sequence= に =C-x 8= や =C-x= が含まれているかをチェック
します。

例えば以下のように設定した場合
#+BEGIN_SRC emacs-lisp
(setq guide-key/guide-key-sequence '("C-x"))
(setq guide-key/recursive-key-sequence-flag t)
#+END_SRC
=C-x r= や =C-x 8= など =C-x= に続くプレフィクスキーを押した際に、キーバイン
ドがポップアップされます。
**** =key-chord= との連携
[[http://www.emacswiki.org/emacs/KeyChord][key-chord]]と連携することができるようになりました。key-chordは、2つのキーの同時
押しに対してコマンドを割り当てることができるようになるライブラリです。2つのキー
の同時押しをプレフィクスキーにすることもできます。

例えばhelm-modeには、helmのコマンドをまとめた =helm-command-map= というキーマッ
プが用意されています。以下のように設定すると、
#+BEGIN_SRC emacs-lisp
(require 'key-chord)
(key-chord-define-global (kbd ":h") helm-command-map)
#+END_SRC
=:= と =p= の同時押しがプレフィクスキーとなり、その後にもう1つキーを入力する
と対応するhelmコマンドが実行できます。

しかし =helm-command-map= にどのコマンドが割り当てられているかは、往々にして
忘れてしまうのでguide-keyでキーバインドをポップアップさせます。

同時押しのプレフィクスキーをポップアップしたい場合、
=guide-key/key-chord-hack-on= を実行する必要があります。その上で以下のように
=guide-key/guide-key-sequence= にkey-chordのプレフィクスキーを追加してください。
#+BEGIN_SRC emacs-lisp
(guide-key/key-chord-hack-on)
(setq guide-key/guide-key-sequence '("<key-chord> : h" "<key-chord> h :"))
#+END_SRC
=:= と =h= のどちらが先に押されるかわからないので、2通りの順番の両方を記述する
必要があります。実際に =:= と =h= を同時押しした様子が以下のようになります。

[[file:/images/guide-key-key-chord.png]]

ちなみに =b= で実行できる =helm-resume= がとても便利です。

=guide-key/recursive-key-sequence-flag= がnon-nilの場合は、シンプルに設定でき
ます。
#+BEGIN_SRC emacs-lisp
(guide-key/key-chord-hack-on)
(setq guide-key/recursive-key-sequence-flag t)
(setq guide-key/guide-key-sequence '("<key-chord>"))
#+END_SRC
この設定の場合は、すべてのkey-chordのプレフィクスキーに続くキーバインドがポッ
プアップされます。

=guide-key/key-chord-hack-on= は =this-command-keys= と
=this-command-keys-vector= という原始的な関数をアドバイスしているため、 *危
険* な可能性があります。一応自分の環境では1年ほど動かして問題は発生していませ
んが、もし異常があるようでしたらレポートいただけると嬉しいです。
**** ポップアップウィンドウのテキストサイズ調整
=guide-key/text-scale-amount= でポップアップするウィンドウのテキストサイズを調
整できるようになりました。テキストを大きくしたい場合は正の数、小さくしたい場合
は負の数に設定してください。

#+BEGIN_SRC emacs-lisp
(setq guide-key/text-scale-amount -1.5)
#+END_SRC
このように-1.5に設定して、実際にポップアップさせると以下のようになります。

[[file:/images/guide-key-text-scale.png]]

小さいポップアップウィンドウで、たくさんのキーバインドが表示できているのが確認
できると思います。テキストサイズを大きくしすぎると、ポップアップウィンドウが大
きくなりすぎて正常に表示できないかもしれませんので注意してください。
*** まとめ
guide-keyの新機能を紹介しました。もし意見などありましたら
twitter({{{twitter(kai2nenobu)}}})やgithub({{{github(kai2nenobu,guide-key)}}})な
どにお願いします。

** org-octopressで記事投稿テスト                             :Emacs:org_mode:
:PROPERTIES:
:EXPORT_FILE_NAME: 2013-12-15-org-octopress-test
:EXPORT_DATE: 2013-12-15
:EXPORT_HUGO_LASTMOD:
:END:


*** org-modeで記事を書く
- [[http://quickhack.net/nom/blog/2013-05-01-org-octopress.html][Octopress の記事を org-mode で - Quickhack Diary]]
を参考にしました。

{{{more}}}
*** テストテスト
**** 整形済み
単純な整形済みテキストは以下のように書く。（# は全角文字になってます）
#+BEGIN_EXAMPLE
＃+BEGIN_EXAMPLE
$ echo hogehoge
hogehoge
＃+END_EXAMPLE
#+END_EXAMPLE
出力は
#+BEGIN_EXAMPLE
$ echo hogehoge
hogehoge
#+END_EXAMPLE
-n オプションで行番号を付加できます。
#+BEGIN_EXAMPLE
＃+BEGIN_EXAMPLE -n
一人目
二人目
三人目
＃+END_EXAMPLE
#+END_EXAMPLE
出力は
#+BEGIN_EXAMPLE -n
一人目
二人目
三人目
#+END_EXAMPLE
css で行番号の部分はコピペできないようにしたけど、もっと見た目でコピーできない
ということを伝えたい。
**** コードブロック
ハイライト付きコードブロック（C++ の場合）
#+BEGIN_EXAMPLE
#+BEGIN_SRC java
package com.example;

public class Main {
  public static void main(String[] args) {
    System.out.println("Hogehoge Hugahuga");
  }
}
#+END_SRC
#+END_EXAMPLE
出力は
#+BEGIN_SRC java
package com.example;

public class Main {
  public static void main(String[] args) {
    System.out.println("Hogehoge Hugahuga");
  }
}
#+END_SRC
整形済みと同様に行番号を付加できます
#+BEGIN_EXAMPLE
#+BEGIN_SRC java -n
package com.example;

public class Main {
  public static void main(String[] args) {
    System.out.println("Hogehoge Hugahuga");
  }
}
#+END_SRC
#+END_EXAMPLE
出力は
#+BEGIN_SRC java -n
package com.example;

public class Main {
  public static void main(String[] args) {
    System.out.println("Hogehoge Hugahuga");
  }
}
#+END_SRC
**** リスト
#+BEGIN_EXAMPLE
- hoge
- huga
- untra
#+END_EXAMPLE
出力は
- hoge
- huga
- untra

**** 数字付きリスト
#+BEGIN_EXAMPLE
1. hoge
2. huga
3. untra
#+END_EXAMPLE
出力は
1. hoge
2. huga
3. untra

**** マークアップ
いろいろな記法で文字を装飾することができます。
#+BEGIN_EXAMPLE
*太字*, /斜体/, _下線_, +取り消し線+, =code=, ~verbatim~
#+END_EXAMPLE
出力は *太字*, /斜体/, _下線_, +取り消し線+, =code=, ~verbatim~ 。あれ、太字
と斜体にならないな。

ただしマークアップ記法の前後は半角スペースや半角コンマなどの区切り文字でないと
マークアップされない。最後の2つの=code=や~verbatim~は等幅フォントで表示したい
時や、文字通り出力したい場合などに便利。
**** 表
|--------+----------|
| hoge   | ほげ     |
|--------+----------|
| huga   | ふが     |
|--------+----------|
| untara | うんたら |
|--------+----------|

**** 画像
画像を表示したい場合には、単純に画像へのファイルのリンクを貼ればよい。
#+BEGIN_EXAMPLE
[[file:/images/google-map.jpg]]
#+END_EXAMPLE
出力は \\
[[file:/images/google-map.jpg]]
\\
画像がローカルのファイルの場合、org2blog が自動的に画像をアップロードしてくれる。

~#+ATTR_HTML~ で画像に属性を追加することができるので、インライン画像の表示幅
なども調節できる。
#+BEGIN_EXAMPLE
#+CAPTION: 都庁付近の地図
#+ATTR_HTML: :alt 都庁付近の地図 :title 都庁付近の地図 :width 320
[[file:/images/google-map.jpg]]
#+END_EXAMPLE
出力は \\
#+CAPTION: 都庁付近の地図
#+ATTR_HTML: :alt 都庁付近の地図 :title 都庁付近の地図 :width 320
[[file:/images/google-map.jpg]]

リンク文字列付きでリンクすれば、画像へのリンクが貼られたテキストになる。
#+BEGIN_EXAMPLE
[[file:/images/google-map.jpg][ぐーぐるまっぷ]]
#+END_EXAMPLE
出力は [[file:/images/google-map.jpg][ぐーぐるまっぷ]]。

次は Web 上の画像をインライン表示してみる。
#+BEGIN_EXAMPLE
#+ATTR_HTML: :alt Emacs の起動画面 :title ヌーヌー :width 400
[[https://www.gnu.org/software/emacs/tour/images/splash.png]]
#+END_EXAMPLE
出力は \\
#+ATTR_HTML: :alt Emacs の起動画面 :title ヌーヌー :width 400
[[https://www.gnu.org/software/emacs/tour/images/splash.png]]

リンク文字列のほうに画像の URL を書けば、画像をインライン表示させつつ画像をク
リックして他の URL に飛ぶこともできる。
#+BEGIN_EXAMPLE
#+CAPTION: A Guided Tour of Emacs
#+ATTR_HTML: :alt Emacs の起動画面 :title ヌーヌー :width 400
[[https://www.gnu.org/software/emacs/tour/][http://www.gnu.org/software/emacs/tour/images/splash.png]]
#+END_EXAMPLE
出力は \\
#+CAPTION: A Guided Tour of Emacs
#+ATTR_HTML: :alt Emacs の起動画面 :title ヌーヌー :width 400
[[https://www.gnu.org/software/emacs/tour/][https://www.gnu.org/software/emacs/tour/images/splash.png]]
**** gist のソースコードを埋め込み
Octopressはデフォルトでgistに対応している。（波括弧は全角になっているが、本来
半角）
#+BEGIN_EXAMPLE
｛% gist gist_id [filename] %｝
#+END_EXAMPLE
と書くことでgistコードを埋め込むことができる。このような形になるように
org-mode のマクロを定義しておく。
#+BEGIN_SRC org
#+MACRO: gist ｛% gist $1 $2 %｝
#+END_SRC

このマクロを定義した上で以下のように書くと、
#+BEGIN_EXAMPLE
｛｛｛gist(2988755,ThisIsTestOfGist.sh)｝｝｝
#+END_EXAMPLE
出力は

# {{{gist(2988755, ThisIsTestOfGist.sh)}}}

となる。あとはCSS次第か。
**** twitter のツイートを埋め込み
WordPress3.4 で twitter の埋込みに対応したらしい。独立した行に URL を書けばい
いらしい。
#+BEGIN_EXAMPLE
https://twitter.com/kai2nenobu/status/217381492052082689
#+END_EXAMPLE
出力は \\
https://twitter.com/kai2nenobu/status/217381492052082689 \\
どうも org-mode の方が URL をリンクに変換してしまうので、うまくいかない模様。

他の書き方もあるのでやってみる。この書き方だとオプションで幅や高さを決めること
もできる。平文で2行目を書いてしまうと、やはり URL がリンクになってしまうので
HTML ブロックで囲むのがよさそう。記号は一部大文字になっています。
#+BEGIN_EXAMPLE
＃+BEGIN_HTML
［embed］https://twitter.com/kai2nenobu/status/217381492052082689［/embed］
＃+END_HTML
#+END_EXAMPLE
出力は
#+BEGIN_HTML
[embed]https://twitter.com/kai2nenobu/status/217381492052082689[/embed]
#+END_HTML

** define-minor-mode で定義されたマイナーモードの挙動                 :Emacs:
:PROPERTIES:
:EXPORT_FILE_NAME: 2013-02-10-minor-mode-behavior
:EXPORT_DATE: 2013-02-10
:EXPORT_HUGO_LASTMOD:
:END:

[[http://d.hatena.ne.jp/syohex/20130209/1360393565][git-gutter.elが minor-mode、global-minor-modeをサポートしました - Life is very short]] を見てて
#+BEGIN_SRC emacs-lisp
(global-git-gutter-mode t)
#+END_SRC
でマイナーモードって有効になるんだっけ？ 引数は正の数じゃないと有効にならない
んじゃないっけ？ と思ったのでちょっと調べてみました。

{{{more}}}
*** 引数による動作の変化
とりあえずマイナーモードの例として ~tool-bar-mode~ の docstring を見てみると
#+BEGIN_EXAMPLE
tool-bar-mode is an interactive compiled Lisp function in `tool-bar.el'.

(tool-bar-mode &optional ARG)

Toggle the tool bar in all graphical frames (Tool Bar mode).
With a prefix argument ARG, enable Tool Bar mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
Tool Bar mode if ARG is omitted or nil.
#+END_EXAMPLE
"With a prefix argument ARG, enable Tool Bar mode if ARG is positive, and
disable it otherwise." を素直に読むと、引数が ~t~ だったら無効になるんじゃねー
のと思いました。

よくわからんのでいろんな引数で評価してみると
#+BEGIN_SRC emacs-lisp
(tool-bar-mode 1)                   ; => t
(tool-bar-mode 999)                 ; => t
(tool-bar-mode 12.345)              ; => t
(tool-bar-mode 0)                   ; => nil
(tool-bar-mode -1)                  ; => nil
(tool-bar-mode -999)                ; => nil
(tool-bar-mode -12.345)             ; => t
(tool-bar-mode '-)                  ; => nil
(tool-bar-mode '(16))               ; => t
(tool-bar-mode t)                   ; => t
(tool-bar-mode nil)                 ; => t
#+END_SRC
こんな感じになりました。 ~(tool-bar-mode -12.345)~ が ~t~ なのが非常にきもいで
すね。どうも非正整数なら無効になるっぽいです。

もっと詳しく調べるために、ソースコードに飛びこみました。最近のマイナーモード
は `define-minor-mode' というマクロを使って定義されていることが多いです。とい
うわけで easy-mmode.el の中の `define-minor-mode' の定義を見てみました。
#+BEGIN_SRC emacs-lisp
(defmacro define-minor-mode (mode doc &optional init-value lighter keymap &rest body)
  ((中略)
       (defun ,modefun (&optional arg ,@extra-args)
	 ,(or doc
	      (format (concat "Toggle %s on or off.
With a prefix argument ARG, enable %s if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil, and toggle it if ARG is `toggle'.
\\｛%s｝") pretty-name pretty-name keymap-sym))
	 ;; Use `toggle' rather than (if ,mode 0 1) so that using
	 ;; repeat-command still does the toggling correctly.
	 (interactive (list (or current-prefix-arg 'toggle)))
	 (let ((,last-message (current-message)))
           (,@(if setter `(funcall #',setter)
                (list (if (symbolp mode) 'setq 'setf) mode))
            (if (eq arg 'toggle)
                (not ,mode)
              ;; A nil argument also means ON now.
              (> (prefix-numeric-value arg) 0)))
           ,@body
           (後略)))))
#+END_SRC
引数 arg の処理は ~(prefix-numeric-value arg)~ の部分ですね。これもいろんな引
数で評価して見ました。
#+BEGIN_SRC emacs-lisp
(prefix-numeric-value 1)                ; => 1
(prefix-numeric-value 999)              ; => 999
(prefix-numeric-value 12.345)           ; => 1
(prefix-numeric-value 0)                ; => 0
(prefix-numeric-value -1)               ; => -1
(prefix-numeric-value -999)             ; => -999
(prefix-numeric-value -12.345)          ; => 1
(prefix-numeric-value '-)               ; => -1
(prefix-numeric-value '(16))            ; => 16
(prefix-numeric-value t)                ; => 1
(prefix-numeric-value nil)              ; => 1
#+END_SRC
なるほど、これが0より大きければマイナーモードが有効になるわけですね。

~prefix-numeric-value~ は対話的なコマンドを呼び出した際の前置引数を、数字とし
て解釈するための関数です。関数を定義する際の ~(interactive "p")~ に相当する関
数です。前置引数は大体の場合には整数しか入力できませんので、整数ならそのまま評
価して、整数以外なら（ ~t~ でも ~nil~ でも float でも）1になる仕様のようです。
float が符号にかかわらず1になるのはちょっと奇妙な感じですね。

ただし ~-~ や ~(16)~ は例外です。 ~-~ は ~C--~ (`negative-argument') を押した
時の、 ~(16)~ は ~C-u~ (`universal-argument') を2回押した時の前置引数に相当し
ます。それぞれ-1、16と評価されます。詳細は
#+BEGIN_SRC emacs-lisp
(Info-goto-node "(elisp)Prefix Command Arguments")
#+END_SRC
を評価して info を読んでください。

というわけで引数が ~t~ ならマイナーモードは有効になります。そしたら "With a
prefix argument ARG, enable Tool Bar mode if ARG is positive, and disable it
otherwise." じゃなくて "With a prefix argument ARG, disable Tool Bar mode if
ARG is *non-positive integer*, and enable it otherwise." の方が正確な気がしま
すけどね。
*** マイナーモードのトグル
マイナーモードは対話的に呼ぶとトグル動作になることは、皆さんご存知かと思います。
Emacs Lisp コードでマイナーモードをトグルにするためには、引数に `toggle' を指
定するか、`call-interactively' で対話的に呼ぶかになります。
#+BEGIN_SRC emacs-lisp
(tool-bar-mode 1)                   ; => t
(tool-bar-mode 'toggle)             ; => nil
(tool-bar-mode 'toggle)             ; => t
(call-interactively 'tool-bar-mode) ; => nil
(call-interactively 'tool-bar-mode) ; => t
(tool-bar-mode nil)                 ; => t
(tool-bar-mode nil)                 ; => t
#+END_SRC
実は以前は ~(tool-bar-mode nil)~ でもトグル動作になっていました。しかし最近に
なって ~(tool-bar-mode nil)~ は無条件でマイナーモードを有効にするように変更さ
れました。

Emacs News にこんな記述があります。
#+BEGIN_EXAMPLE
 * Incompatible Lisp Changes in Emacs 24.1

 ** Passing a nil argument to a minor mode function call now ENABLES
 the minor mode unconditionally.  This is so that you can write e.g.

  (add-hook 'text-mode-hook 'foo-mode)

 to enable foo-mode in Text mode buffers, removing the need for
 `turn-on-foo-mode' style functions.  This affects all mode commands
 defined by `define-minor-mode'.  If called interactively, the mode
 command still toggles the minor mode.
#+END_EXAMPLE
フックに引っ掛けるときの利便性のための変更のようです。上の評価は Emacs 24.2 で
やっているので、 ~(tool-bar-mode nil)~ はトグルじゃなくて有効操作になっていま
す。

というわけで、くれぐれも ~(tool-bar-mode nil)~ でモードがトグルするとか無効に
なると思ってはいけません。自分は設定ファイルでモードの有効無効を設定する際に
~(tool-bar-mode t)~ と ~(tool-bar-mode 0)~ と書くのは対称性がなくて好きじゃな
いので、 ~(tool-bar-mode 1)~ と ~(tool-bar-mode 0)~ と書くようにしてます。
*** まとめ
- ~(hoge-mode t)~ でマイナーモードは有効になります。
- モードを無効にしたい時は ~(hoge-mode arg)~ の arg を0以下の整数にしましょう。
  ~(hoge-mode nil)~ ではモードは無効になりません。
- Emacs 24.1 以上なら ~(hoge-mode nil)~ はトグル動作ではなく、モードが有効にな
  ります。なので、もしなにかのモードのフックに引っ掛けてマイナーモードを有効に
  する
  #+BEGIN_SRC emacs-lisp
(add-hook 'huga-mode-hook (lambda () (hoge-mode 1)))
  #+END_SRC
  みたいなコードがある場合は
  #+BEGIN_SRC emacs-lisp
(add-hook 'huga-mode-hook 'hoge-mode)
  #+END_SRC
  とすっきり書きなおすことができます。
- docstring の記述はやや不正確。
*** [2013-02-11 Mon 10:58] 追記
対称性を考えると、モードの有効無効を ~(hoge-mode 1)~ と ~(hoge-mode -1)~ で書
く人もいらっしゃるようです。Emacs 24.2の標準添付のライブラリでは0派と-1派のど
ちらが多いか調べてみました。参考に1の数も書いておきます。
#+BEGIN_EXAMPLE
$ find local/share/emacs/24.2/lisp -name "*.el.gz" | xargs zgrep -e '([^ ]\+-mode 1)' | wc -l
193
$ find local/share/emacs/24.2/lisp -name "*.el.gz" | xargs zgrep -e '([^ ]\+-mode 0)' | wc -l
57
$ find local/share/emacs/24.2/lisp -name "*.el.gz" | xargs zgrep -e '([^ ]\+-mode -1)' | wc -l
80
#+END_EXAMPLE
おお、-1派の方が多いようですね。自分も-1派に転じてみましょうか。

番外編で ~t~ と ~nil~ です。
#+BEGIN_EXAMPLE
$ find local/share/emacs/24.2/lisp -name "*.el.gz" | xargs zgrep -e '([^ ]\+-mode t)' | wc -l
100
$ find local/share/emacs/24.2/lisp -name "*.el.gz" | xargs zgrep -e '([^ ]\+-mode nil)' | wc -l
99
#+END_EXAMPLE
ただこれは ~(let ((hoge-mode nil))~ みたいに変数に束縛しているケースもたくさん
含まれている（特に ~nil~ ）ので、あくまで参考です。

** Emacs で自動的にキーバインドをポップアップする guide-key :Emacs:guide_key:
:PROPERTIES:
:EXPORT_FILE_NAME: 2012-12-03-emacs-advent-calendar-2012-03
:EXPORT_DATE: 2012-12-03
:EXPORT_HUGO_LASTMOD:
:END:

[[http://qiita.com/advent-calendar/2012/emacs][Emacs Advent Calendar 2012 - Qiita]] の3日目です！ [[http://qiita.com/items/16bd5cb65be18e804c63][Qiita の投稿]]では軽く設定を説
明しただけなので、こちらではもう少し詳しく説明します。

自動的にキーバインドをポップアップするライブラリ、[[https://github.com/kbkbkbkb1/guide-key][guide-key.el]] を自作したので
紹介したいと思います。

{{{more}}}
*** 開発の動機
Emacs を利用する場合の大きな障壁の1つにキーバインドの覚えにくさがあるでしょう。
1ストロークのキーバインドは頻繁に使いますし、まだ覚えやすいですが、2ストローク
以上のキーは頻繁に使うものしか覚えていない、という人も多いのではないでしょうか。
ましてや新しく導入した外部ライブラリのキーバインドなどは覚えるのが億劫になりま
す。Emacs には標準で ~describe-key~ や ~describe-bindings~ などキーバインドを
調べる機能もありますが、必ずしも使いやすくありませんし、能動的にコマンドを実行
しないといけません。

この問題を解決する外部ライブラリとして有名なのが [[http://emacswiki.org/emacs/one-key.el][one-key.el]] です。このライブラ
リを使えば、プレフィクスキーを押した際に、そのプレフィクスに続くキーを自動
的に（別ウィンドウに）表示してくれます。下図は one-key.el を導入して ~C-x r~
を押したときの様子です。

[[file:/images/one-key-example.png]]

しかし one-key.el にもいくつか問題があります。
- プレフィクスに続くキー（テンプレート）を自分で記述しないといけないません。
  主要なプレフィクスキーのテンプレートはあらかじめ用意してありますが、自分で
  書く場合は手間がかかります。その手間を軽減してくれるジェネレータを
  rubikitch さんが[[http://d.hatena.ne.jp/rubikitch/20090127/onekey][こちら]]で書いてくれていますが、やはりめんどくさい。
- キーマップのキーバインドを変更した場合、テンプレートの方も手動で変更しなけれ
  ばなりません。テンプレートが自動的にキーマップに追随してくれたらいいのに。
- one-key.el はプレフィクスキーに割り当ててあるコマンドを置き換えます。つま
  りデフォルトでは ~C-x r~ に割り当てられている ~ctl-x-r-prefix~ を上書きして
  しまうのでいろいろ問題が出てきます。例えば ~describe-key~ で ~C-x r t~ に割
  り当てられているコマンドを調べようとすると、 ~C-x r~ に割り当てられている
  one-key のコマンドが先に出てきてしまい、直接 ~C-x r t~ を調べることができな
  くなってしまいます。

以上の問題点を解決した [[https://github.com/kbkbkbkb1/guide-key][guide-key.el]] というのを作ってみました。キーマップに自
動的に追随してくれますし、コマンドを上書きするようなこともありません。
*** guide-key.el の導入
[[http://melpa.milkbox.net/][MELPA]] に登録しているので、package.el を使ってインストールできます。Emacs24 の
人や package.el を自分で入れている人は init.el に
#+BEGIN_SRC emacs-lisp
(add-to-list 'package-archives
             '("melpa" . "http://melpa.milkbox.net/packages/") t)
#+END_SRC
と設定すると、MELPA に登録されているパッケージを見ることができます。 ~M-x
list-packages~ を実行してパッケージをリストアップし、 ~i~ で guide-key を選
択、~x~ で実行することにより guide-key がインストールされます。guide-key は
[[https://github.com/m2ym/popwin-el][popwin]] に依存しているので、package.el でインストールすれば自動的に popwin もイ
ンストールされます。

#+ATTR_HTML: :alt packageでguide-key.elをインストールする図 :title guide-key.elのインストール :width 640
[[file:/images/guide-key-package-install.png]]

package.el がない人は [[https://github.com/m2ym/popwin-el][m2ym/popwin-el]] と [[https://github.com/kbkbkbkb1/guide-key][kai2nenobu/guide-key]] から popwin.elと
guide-key.el を直接ダウンロードしてきて、適当に ~load-path~ が通っているところ
に保存してください。
*** 使い方
~guide-key/guide-key-sequence~ にポップアップして欲しいキーシーケンス（プレ
フィックスキー）を登録します。init.el に以下のように設定してください。
#+BEGIN_SRC emacs-lisp
(require 'guide-key)
(setq guide-key/guide-key-sequence '("C-x r" "C-x 4"))
(guide-key-mode 1)  ; guide-key-mode を有効にする
#+END_SRC
これで ~C-x r~ や ~C-x 4~ を押した時に、次に続くキーを表示するウィンドウが自動
的にポップアップされます。実際に ~C-x r~ に押した様子はこのようになります。

[[file:/images/guide-key-example.png]]

guide-key は特定の正規表現に当てはまるコマンド名に色をつけることができます。
~C-x r~ には rectangle 系と register 系のコマンドがあります。いま rectangle 系
のコマンドに色をつけて目立たせたいとすると以下のように設定します。
#+BEGIN_SRC emacs-lisp
(setq guide-key/highlight-command-regexp "rectangle")
#+END_SRC
また ~C-x r~ に続くキーバインドを変更した時に、自動的に追随するかを確かめるた
めにキーバインドを追加します。
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x r 3 a") 'hoge)
(global-set-key (kbd "C-x r 4") 'ctl-x-4-prefix)
#+END_SRC
この設定で ~C-x r~ を押すとこうなります。

[[file:/images/guide-key-example2.png]]

このように rectangle 系のコマンドだけが色付けされます。これでコマンドを探しや
すくなりますし、キーバインドを覚えやすくなります。またキーバインドの変更に追随
して、 ~ctl-x-4-prefix~ や ~Prefix Command~ が表示されています。

rectangle 系、register 系どちらも色付けしたければ
#+BEGIN_SRC emacs-lisp
(setq guide-key/highlight-command-regexp "rectangle\\|register")
#+END_SRC
のように、適当に正規表現を設定してください。またプレフィクスキー（"prefix"
という正規表現に一致するコマンド）にも自動的に色付けがされます。
*** 特定のモードで設定を追加
こういったキー入力を補助して欲しい場面は、おそらく新しく導入したモードに独自の
キーバインドがある場合でしょう。「さっきマニュアルを見たのに、もうキーバインド
を忘れた」ということが起きないように、以下では guide-key を使って特定のモード
に対して設定を追加します。

~guide-key/add-local-guide-key-sequence~
と~guide-key/add-local-highlight-command-regexp~ を使うと現在のバッファの変数
のみを変更できます。これを特定のモードのフックと組み合わせれば、特定のモードに
対して設定を追加できます。

例えば org-mode を例にとって見ると、以下のような設定になります。
#+BEGIN_SRC emacs-lisp
(defun guide-key/my-hook-function-for-org-mode ()
  (guide-key/add-local-guide-key-sequence "C-c")
  (guide-key/add-local-guide-key-sequence "C-c C-x")
  (guide-key/add-local-highlight-command-regexp "org-"))
(add-hook 'org-mode-hook 'guide-key/my-hook-function-for-org-mode)
#+END_SRC
この設定をした後、org-mode のバッファで ~C-c C-x p~ を押して
~org-set-property~ が実行される様子が以下の図です。

[[file:/images/guide-key-example-org-anime.gif]]

色付けする正規表現に "org-" を追加しているので、ほとんどのコマンドが色付けされ
ています。これだとあまり意味が無いので、覚えたいコマンド群のみが色付けされるよ
うに、もっと絞り込める正規表現に好みで変更してください。

メジャーモードでもマイナーモードでもフックさえあれば同様のことができるので、
お好きなモードで試してみてください。
*** その他詳細
guide-key の動作は簡単で、定期的に現在入力されているキーシーケンスをポーリング
で調べ、 ~guide-key/guide-key-sequence~ に含まれる場合は次に続くキーをポップアッ
プするだけです。次に続くキーは ~describe-buffer-bindings~ でその度に取得してい
るので、動的にキーバインドの変更に追随できます。キーを入力するたびに実行される
ようなフックがあればポーリングでなくても良かったんですが、そんなフックは存在し
ないようです。最小単位のフックは、コマンドを実行するときの
~post-command-hook~ か ~pre-command-hook~ のなのかな。

現在入力中のキーシーケンスは ~this-command-keys-vector~ で取得することができま
す。Emacs 内部でのキーイベントの表現は、[[http://d.hatena.ne.jp/uk-ar/20120213/1329138385][Emacsでキーボードイベントを扱う方法ま
とめ - むしゃくしゃしてやった]]を参考にしました。プレフィクスキー ~C-x r~ の文
字列表現は "C-x r" か "\C-xr" の2種類ありますが、
~guide-key/guide-key-sequence~ はどちらの表現でも受け付けますし、混在でも構い
ません。

ポップアップウィンドウの制御はすべて popwin に任せています。自分でウィンドウ構
成の保持や、ポップアップする位置を調整したりする部分を自分で書く必要がなく、とっ
ても楽にコードが書けました。popwin の作者の [[http://cx4a.blogspot.jp/][m2ym]] さんには感謝を申し上げます。

guide-key の動作を制御する変数などを説明しておきます。
- ~(guide-key-mode ARG)~: ~guide-key-mode~ はマイナーモードで実装されています。
  対話的に実行すればトグル動作になるので、一時的に有効無効を切り替える場合は
  ~M-x guide-key-mode~ を実行してください。グローバルマイナーモードなので、特
  定のバッファのみで有効にする、といったような動作はできません。全バッファ共通
  で有効か無効かのどちらかです。
- ~guide-key/popup-window-position~: ポップアップするウィンドウの位置を制御す
  る変数です。 ~right~, ~bottom~, ~left~, ~top~ のいずれかを指定してください。
  デフォルトは ~right~ です。
- ~guide-key/polling-time~: 入力されているキーシーケンスをポーリングする間隔を
  制御する変数です。デフォルトは0.1です（秒単位）。キーを押してすぐさまポップ
  アップされるのが嫌な場合は長くするといいでしょう。おそらく0.1でもほぼ一瞬で
  表示されるように感じると思います。0.01ぐらい短くしてもきちんと動作し、他の操
  作にも影響が無いことを確認していますが、0.1で大多数の人は問題ないと思います。

guide-key が動作することを確認している環境は以下のようになります。
- Emacs 24.2, Ubuntu 12.04 or Windows 7 64bit
- Emacs 23.3, Ubuntu 12.04 or Windows 7 64bit
- Emacs 22.3, Windows 7 64bit
とにかく popwin が動けば guide-key も動作するはずです。ターミナル環境の Emacs
でも問題なく動作します。
*** まとめ
最後に guide-key の特徴をまとめておきます。
- 現在入力しているキーシケンスに続くキーを自動的にポップアップします。ポップアッ
  プさせたいプレフィクスを設定するだけで使えます。また動的にキーバインドを調
  べているので、キーバインドが変更されても動的に追随できます。
- 特定のコマンドを色付けすることできます。いま注目している機能に関するコマンド
  だけを色付けすることにより、キーバインドを探しやすくなり体で覚えることがで
  きます。
- 既存のコマンドを上書きしないので、 ~describe-key~ や ~describe-bindings~ な
  どに影響が出ません。

既知の問題点、欠点には以下のようなものがあります。
- guide-key は次に続くキーバインドをすべて表示しようとするので、ポップアップウィ
  ンドウのサイズが大きくなりがちです。もし現在のフレームの大きさよりポップアッ
  プウィンドウの方が大きくなると、正常にポップアップされなくなります。なのでフ
  レームを大きくするか、キーバインドが少ないプレフィクスのみを設定してくださ
  い。キーバインドの多い ~C-x~ などをポップアップさせるのは、全くの初心者の人
  以外はあまりお勧めしません。将来的には、ポップアップするコマンドの方を個数や
  正規表現で制限する機能を追加するかもしれません。
- またポップアップされるキーバインドが多すぎると、目視で目的のコマンドを探すこ
  とが難しくなります。ポップアップされるコマンドの個数、あるいは色付けされたコ
  マンドの個数が数個〜十数個ぐらいになるのが理想的かと思います。
- キーバインドをポップアップさせようとした時、一瞬ポップアップされて一瞬で閉じ
  てしまうことがあります。popwin で制御されているウィンドウ（デフォルトだと
  Help バッファや Apropos バッファなど）を閉じた直後に起こることが多いですが、
  他の場面でもたまにあります。そういうときは C-g を連打したり、他のコマンドを
  実行して仕切りなおしてからもう一回プレフィクスキーを入力してみてください。
- one-key ではコマンド名の代わりに、短い説明文字列を表示させることが出来ました。
  これは手動でテンプレートを作っているからこその利点です。guide-key では動的に
  キーバインドからコマンドを抽出してくるので、コマンド名しか表示させることが
  できません。

自分としてはキーバインドが変更されても追随するという事を最重要視して作りまし
た。guide-key を使えばもっとキーバインドを覚えやすくなると思いますので、みな
さんぜひ使ってみてください。

** percol の追加機能いろいろ                                :percol:zsh:tool:
:PROPERTIES:
:EXPORT_FILE_NAME: 2012-11-21-percol-new-features
:EXPORT_DATE: 2012-11-21
:EXPORT_HUGO_LASTMOD:
:END:

[[https://github.com/mooz/percol][percol]] が粛々とアップデートされているので、追加機能をいろいろ紹介します。ほと
んどのことが README.md に書いてあるので、詳しくはそちらを。

{{{more}}}
*** percol 起動中のトグル操作
~--match-method~ オプションでマッチメソッドを変更できますが、percol が起動中に
もマッチメソッドが変更できるようになりました。また大文字小文字を考慮するかも切
り替えられるようになりました。

~toggle_finder()~ というコマンドを使うと、現在のマッチメソッドと指定したマッチ
メソッドをトグルできます。 ~toggle_case_sensitive()~ で大文字小文字の考慮をト
グルです。README に書いてある ~/.percol.d/rc.py の設定例は以下。
#+BEGIN_SRC python
from percol.finder import FinderMultiQueryMigemo, FinderMultiQueryRegex
percol.import_keymap({
    "M-c" : lambda percol: percol.command.toggle_case_sensitive(),
    "M-m" : lambda percol: percol.command.toggle_finder(FinderMultiQueryMigemo),
    "M-r" : lambda percol: percol.command.toggle_finder(FinderMultiQueryRegex)
})
#+END_SRC

自分は regex <-> string のトグルと、migemo <-> string のトグルをして欲しかった
ので、自分で ~toggle_two_finders()~ というコマンドを作りました。
percol/command.py に ~toggle_finder()~ を真似して

# {{{gist(4123942,percol_toggle_two_finder.py)}}}

を追記し、percol を再インストールして rc.py を以下のように設定しています。
#+BEGIN_SRC python
from percol.finder import FinderMultiQueryString, FinderMultiQueryMigemo, FinderMultiQueryRegex
percol.import_keymap({
    "M-c" : lambda percol: percol.command.toggle_case_sensitive(),
    "M-m" : lambda percol: percol.command.toggle_two_finders(FinderMultiQueryMigemo, FinderMultiQueryString),
    "M-r" : lambda percol: percol.command.toggle_two_finders(FinderMultiQueryRegex, FinderMultiQueryString)
})
#+END_SRC
これでだいぶ Emacs ライクな操作性になりました。migemo のトグルは C-e かと思っ
てましたが、最近の migemo.el は M-m になってるらしいので、M-m にした。
*** プロンプトのカスタマイズ
プロンプト文字がカスタマイズできるようになりました。多分もとからできたんだと
思いますが、README に新たに追加されたので紹介。

~PROMPT~ が左のプロンプト、 ~RPROMPT~ が右のプロンプトを表しています。クラス内
の変数に応じてプロンプトを変更したり、自分独自の format specifier を定義したり
できます。自分の設定はこのようになっています。README の設定とほぼ同じです。
#+BEGIN_SRC python
# Change PROMPT in response to the status of case sensitivity
percol.view.__class__.PROMPT = property(
    lambda self:
    ur"<bold><cyan>QUERY </cyan>[a]:</bold> %q" if percol.model.finder.case_insensitive
    else ur"<bold><yellow>QUERY </yellow>[A]:</bold> %q"
)
# Display finder name in RPROMPT
percol.view.prompt_replacees["F"] = lambda self, **args: self.model.finder.get_name()
percol.view.RPROMPT = ur"\<%F\> (%i/%I) [%n/%N]"
#+END_SRC

この設定でプロンプトはこうなります。

#+ATTR_HTML: alt="percolのプロンプト例" title="プロンプトの例"
[[file:/images/percol_prompt_example.png]]

~[a]~ の部分で大文字小文字の考慮が、~<string>~ の部分で現在のマッチメソッドが
わかります。これでがんがんトグルできます。他にも文字色や背景色の変更や装飾もで
きるので、自分好みにカスタマイズしましょう。
*** 日本語を含む履歴検索
percol を一番利用しているのが zsh の履歴検索なんですが、日本語が文字化けしてし
まうのが難点でした。最近 history コマンドをつかうと、ちゃんと日本語が含まれた
コマンドも参照できることに気づきました。

そして percol の README もいつの間にか history コマンドを使うようになってまし
た。なのでそのまま引用します。
#+BEGIN_SRC sh
function exists { which $1 &> /dev/null }

if exists percol; then
    function percol_select_history() {
        local tac
        exists gtac && tac="gtac" || { exists tac && tac="tac" || { tac="tail -r" } }
        BUFFER=$(history -n 1 | eval $tac | percol --query "$LBUFFER")
        CURSOR=$#BUFFER         # move cursor
        zle -R -c               # refresh
    }

    zle -N percol_select_history
    bindkey '^R' percol_select_history
fi
#+END_SRC

これを .zshrc に追加して、履歴検索するとこうなります。

#+ATTR_HTML: alt="日本語を含むコマンドをの検索" title="日本語を含むコマンドをの検索"
[[file:/images/percol_history_search_japanese.png]]

ばっちり日本語も表示できています。これで履歴検索は完璧ですね。
*** その他もろもろ
あとは自分があまり理解してなかったり、試してないのでさらっと。
- PyPI からインストールできるようになりました。PyPI は python のパッケージ管理
  システムなんですよね？
- Lazy Array での検索が可能になりました。。Lazy Array がよくわかってないですが、
  全部の候補を検索してから表示するのではなく、候補を検索したはしから順々に表示
  されるってこといいんですかね？ 候補数が正確に表示されない代わりに、パフォー
  マンスの向上が狙えるようです。デフォルトで有効になるので、無効にしたい場合は
  ~--eager~ オプションをつけましょう。
*** おわりに
少しずつ percol が便利になってます。あとは percol のクエリを履歴に保存しておく
機能があると非常に便利そう。んで ~M-p~ 、 ~M-n~ で参照できると。熟練の
pythonista なら実装してくれるはず…|дﾟ)ﾁﾗｯﾁﾗｯ

もっとユーザーが増えて、もっとハックされていくといいですね。みんなでもっと
percol を使いましょう！

** 光回線を解約して WiMAX に一本化。URoad-Home は優秀               :network:
:PROPERTIES:
:EXPORT_FILE_NAME: 2012-09-09-wimax-uroad-home
:EXPORT_DATE: 2012-09-09
:EXPORT_HUGO_LASTMOD:
:END:

いままで[[http://www.auhikari.jp/][auひかり]]の光回線を契約していたが、現在は家の回線と外で使うための回線も
含めて WiMAX に一本化しました。その経緯と WiMAX の使い勝手を紹介しようと思いま
す。
{{{more}}}
*** まず Mobile Cube を購入する
1年ほど前に iPod touch を購入したので、それを屋外でも通信できるように WiMAX
を利用したいと思い始めました。[[http://kakaku.com/][価格.com]] のプロバイダ料金をチェックした結果、一
番安かった [[http://dream.jp/][DTI]] と契約して WiMAX 端末の [[http://nwcs.co.jp/product/mobilecube/][Mobile Cube]] を購入しました。といっても
機器料金は0円で、回線料金は3,880円/月（2年縛り）です。

Mobile Cube の見た目はこんな感じです。

#+ATTR_HTML: :alt Mobile Cube の外観図 :title Mobile Cube :width 640
[[https://nwcs.co.jp/product/mobilecube/index.html][https://nwcs.co.jp/product/mobilecube/img/name.png]]
- 重さ89g
- 連続通信時間10時間
- 同時接続数8台
といった性能で、小さくて電池がもついい端末だと思います。特に通信時間は（当然通
信量にもよりますが）公称されている時間程度は実際にもっているので、一日の途中で
充電する必要がなく安心です。持ち運び用に専用ケースがついているのもGoodです。

通信速度の方は屋外で使う分には十分な1Mbpsほどでていたので、満足できるものでし
た。また自宅内で使っても中程度の電波強度だったので、ウェブブラウジング程度では
特に光回線との違いも感じられないぐらいの快適さでした。

問題なのは料金で、この時点では光回線と併用していたので
- 光回線: 6,000円程/月
- WiMAX 回線: 3,880円/月
で月1万円というのは少々高すぎると感じていました。
*** 自宅内も WiMAX 回線を使用する
さっさと光回線を解約してしまえば料金は安くなるのですが、このウェブサーバは自宅
サーバなので自分が自宅にいない間の通信回線が必要です。といってもそれだけのため
に光回線は仰々しすぎます。2012年7月に光回線の2年縛りが満期になったので、光回線
の代わりに新たに WiMAX 回線を契約することにしました。

自宅内で使うので WiMAX 端末に有線のポートがあるものを探していました（自宅サー
バは無線 LAN 通信不可）。最初は充電機能も兼ねるクレードルがついている端末にし
ようかと思っていたのですが、[[http://www.shinseicorp.com/wimax/uroad-home/index.shtml][URoad-Home]] という非常に有能な端末が発売されていま
した。

#+ATTR_HTML: :alt URoad-Home の外観図 :title URoad-Home :width 640
[[http://www.shinseicorp.com/wimax/uroad-home/gallery.shtml][https://news.mynavi.jp/article/20111212-uroad_home/images/001.jpg]]

URoad-Home ははじめから自宅内で利用するように想定された非携帯用の WiMAX 端末で、
有線 LAN ポートが2つあるのが今回の用途にぴったりです。この端末の特徴は
- 100BASE 有線 LAN ポートが2つ
- SSID は2つあり、1SSID につき5台同時接続可能
- WiMAX ハイパワーなる機能がついており、電波がつながりやすいらしい
といった感じです。

この端末を販売しているプロバイダは少ないですが、私は本家 [[http://www.uqwimax.jp/][UQ WiMAX]] で1年縛りの
UQ Flat 年間パスポート（3,880円/月）に契約することにしました。肝心の通信速度の
ほうですが、Mobile Cube とあまり変わらず1Mbpsほど出ていてブラウジングでの違和
感は特にありません。また有線接続のためか通信が安定しているように感じます。ため
しにネットゲームもしてみましたが、あまりグラフィック性能を必要としない2Dゲーム
だったためかラグも殆ど感じず快適でした。とはいえ当然有線より遅延は大きいため、
グラフィック性能が求められるFPSなどでは気になるという[[http://www.4gamer.net/games/032/G003289/20120328097/][レポート]]もあるようです。

また固定回線ではない WiMAX でサーバの運用ができるかが気になっていましたが、ど
こからこのウェブサーバにアクセスしても全く以前と変わらない感触でアクセスするこ
とができました。所詮ウェブサーバだけで通信量は小さくアクセス数も少ないですから、
全然固定回線とかわらず運用できるようで拍子抜けしました。

これで料金の方は
- Mobile Cube (DTI): 3,880円/月
- URoad-Home (UQ-WiMAX): 3,880円/月
となり、少し安くなりました。
*** 1つ WiMAX 回線を解約し、1回線2機器で運用する
UQ-WiMAX と契約してからふと思いました。

***「WiMAX 2回線って無駄じゃね？」*

もともと iPod を屋外で使うために契約した Mobile Cube ですが、思ったより屋外で
通信する頻度も少ないので Mobile Cube だけのために月3,880円払うのが勿体無く感じ
てきました。ここで [[http://www.uqwimax.jp/service/price/option04.html][WiMAX 機器追加オプション]]というサービスが登場します。既に契
約している回線に対して WiMAX 端末を追加することができます。つまり、今
URoad-Home で使用している回線に Mobile Cube を追加すれば、どちらの端末からの通
信でも1つの回線を介して利用できるようになります。しかし回線が1つなのは変わらな
いので、両方の端末同時に通信することはできません。

いままで機器追加って何に使うんだ、と思ってましたがこういう時のためにあるんだと
得心がいきました。というわけで DTI の契約を途中で解約することにしました。2年縛
り中なので違約金9,600円が発生しましたが、だらだらと続けるよりは安上がりです。
UQ-WiMAX で Mobile Cube を機器追加すると200円/月かかります。

機器追加をして気になるのは2端末での同時通信ができないというところです。しかし
実際に使ってみるとほとんど問題がありませんでした。試しに Mobile Cube を介して
iPod でウェブブラウジングしながら別のマシンで自宅サーバにアクセスしてみました
が、ほとんど通信が途絶しているようには感じられませんでした。ウェブブラウジング
は通信が断続的なので影響がないように見えるのかもしれません。

これで月々の料金は
- URoad-Home (UQ-WiMAX): 3,880円/月
- Mobile-Cube（機器追加）: 200円/月
となりました。最初の光回線 + WiMAX 回線とは雲泥の差です。
*** まとめ
光回線と比べた時、WiMAX のメリットや1回線2機器によるメリットは以下の様な点です。
- なにより安い。固定回線 + モバイル通信回線というのは高くならざるをえない。ボッ
  タクリのパケホーダイなどの代わりに利用すれば効果は抜群です。
- 通信速度はそれなりに早い。完全に光回線と同じというわけには行きませんが、日
  頃のネットワーク通信の95％は光回線と変わりません。
- 必要な機器が少ない。光回線の場合、終端装置やホームゲートウェイなど必要な機器
  が多く、配線が複雑になったりコンセントがタコ足になりがちです。URoad-Home な
  らAC電源1つだけでOK。
- 工事が要らない。自宅への回線の引き込みなどがいらないので、無駄な金をとられる
  こともなく手間がかからない。また引越しの際は URoad-Home を引越し先に持ってい
  けばいいだけなので引越しが楽。これは借家ぐらしには非常に大きなメリットだと思
  う。
- 意外とサーバ運用も出来る。サーバ運用は固定回線がないといけない、となんとなく
  思ってましたがそんなことはなかった。ウェブサーバは以前と全く同じように動いて
  います。遅延があると困るようなサービスでなければ、大概大丈夫なのではないかと
  思います。
- 2機器の同時通信不可はほとんど気にならない。自分のサーバはアクセス数がとても
  少ないので、Mobile Cube と URoad-Home の通信が同時に起こることがほぼないよ
  うです。
なんか書いてて、「業者かっ」と自分で感じてきました。

逆に光回線ではなくなったデメリットは以下のような点。
- LAN 内の通信はとても遅くなる。URoad-Home の有線 LAN ポートは100BASE
  (100Mbps) なので、光回線で1000BASEを使ってる時と比べると10分の1ぐらいになり
  ました。頻繁に LAN 内でやり取りしている人は気になるかもしれません。
- 遅延が気になる時もある。やはり固定回線と比べると遅延が大きくなります。ssh で
  外のサーバにログインして操作すると若干のもたつきを感じ、光回線の時より少し快
  適さが失われています。といってもそんなに大きな遅延ではない（ping が100msかか
  るくらい）ので操作はちゃんと出来ます。
- URoad-Home の（無線での）同時接続数が5台しかない。ちょっと大きな自宅内 LAN
  を構成しようと思うと、5台は非常に少ないです。
- URoad-Home のルータ機能はそれなり。基本的な機能はありますが、本格的なルータ
  よりはだいぶしょぼいです。ポートフォワーディングの設定が16件しか保持できな
  かったり、IP、MAC、ポートによるフィルタリングの設定が一緒くたで16件しか保持
  できなかったりします。今はまだ足りていますが、運用するサーバを増やすと足り
  なくなるかもしれない。

個人的には総じてメリットのほうが上回っており、回線変更してよかったと思います。
今考えると光回線の帯域のほとんどが使えてなかったのだと感じました。もはや光回線
は戸建のファミリー層にしか必要ないのではないでしょうか。単身者には圧倒的に
WiMAX 推しですね。

** percol を用いたファイル名の補完コマンドを書きました      :percol:zsh:tool:
:PROPERTIES:
:EXPORT_FILE_NAME: 2012-06-29-percol-file-completion
:EXPORT_DATE: 2012-06-29
:EXPORT_HUGO_LASTMOD:
:END:

最近 [[https://github.com/mooz/percol][percol]] をヘビーに使っています。percol は入力された文字列を部分一致かつ
AND 検索で絞り込んでくれるコマンドなので、ファイル名の絞り込み、補完に使えない
わけがないと思っていました。

[[./2012-04-29-percol-introduction.org][以前のエントリ]]でファイル名の補完として ~insert-file-by-percol~ というのを紹介
しましたが、少々機能不足でした。今回は空気を読んでファイル名を補完、絞り込みし
てくれる zsh のコマンド ~complete-filename-by-percol~ を書きましたので紹介します。

{{{more}}}
*** 動作
~complete-filename-by-percol~ は何を絞り込みの候補とするかを、空気を読んで変え
てくれます。カーソル位置にある引数を ~ARG~ とすると以下のものが絞り込みの候補に
なります。
- ~ARG~ が空白の場合
  - カレントディレクトリを ls したファイル群
- ~ARG~ が一意なディレクトリの場合
  - ~ARG~ を ls したファイル群
- その他の場合
  - ~ARG*~ （* はグロブです）に合致するファイル群

また絞り込みの候補の数に応じて動作を変えてくれます。
- 絞り込みの候補が0個の場合
  - エラーメッセージを表示してコマンド終了
- 絞り込みの候補が1個の場合
  - その候補をコマンドラインに挿入してコマンド終了
- 絞り込みの候補が2個以上の場合
  - percol を使って絞り込みし、選択されたものをコマンドラインに挿入してコマン
    ド終了。複数ファイルをマークした場合は、全てのファイルが挿入されます

ファイル名中の空白や記号に関しては適切にエスケープしてあるので、問題なく絞り
込みできるはずです。
*** 動画
まずはどんな動作をするか見てもらったほうが早いと思うので、動画をとってみました。

[[http://www.youtube.com/watch?v=SpujuVQfjuk]] （できれば後ほど埋め込む）

動画ではわかりにくいかもしれませんが ~Ctrl+j~ で補完コマンドが発動しています。
*** ~complete-filename-by-percol~ のコード
空気を読んでくれるが故に条件分岐が多く少々長くなってしまいましたが、以下がその
コードです。これを .zshrc に書いておくと使えるようになります。ショートカットキー
は ~Ctrl+j~ にしましたが、お好みのキーへ設定してください。

# {{{gist(2978183,gistfile1.sh)}}}

*** 詳細解説
上で「カーソル位置にある引数を ~ARG~ とする」と説明しましたが、正確には「引数
上か、引数の右隣の空白にカーソルがある場合その引数を ~ARG~ とする」で
す。~complete-filename-by-percol~ でディレクトリを補完すると、その右隣の空白に
カーソルが移動するのでもう1回 ~Ctrl+j~ を押せばそのディレクトリをさらに掘るこ
とができます。percol の決定も ~Ctrl+j~ でできるので、 ~Ctrl+j~ を連打すればど
んどんディレクトリを掘り進められます。とても楽です。

~complete-filename-by-percol~ はファイルよりも一意なディレクトリを優先します。
たとえば
#+BEGIN_EXAMPLE
$ ls -F
example/  example.tar.gz
#+END_EXAMPLE
というよくあるディレクトリを考えます。
#+BEGIN_EXAMPLE
$ ls example
#+END_EXAMPLE
このようなコマンドライン上で example 上にカーソルがあるとします。この状態で
complete-filename-by-percol を発動すると、example と example.tar.gz の絞り込み
ではなく、example ディレクトリ中のファイルの絞り込みになります。これはディレク
トリを掘り進めるほうが需要があるだろうと思った為です。example.tar.gz を補完し
たければ ~TAB~ などでやるといいでしょう。example と example.tar.gz が両方共ファ
イルであれば、単純に percol による絞り込みになります。

関数の中で ~split-shell-arguments~ や ~modify-current-argument~ を用いているの
で、autoload する必要があります。これらのコマンドが、シェルの引数を空白や記号
のエスケープを考慮してパースしてくれるので、非常に楽に書くことができました。そ
のへんのパースを自分で書くのは骨が折れそうです。これらのコマンドについては
~man zshcontrib~ をご覧ください。

また1行目の ~set no_nomatch~ についてです。zsh は標準ではグロブの展開に失敗し
た（グロブに合致する候補が1つもない）場合には zsh がエラーを出してコマンドが終
了してしまいます。なので ~ARG*~ に合致する候補が1つもない場合、コマンドが途中
で終了してしまいます。 ~set no_nomatch~ することにより zsh によるエラーを避け
ることができます（かわりに ls のエラーになります）。候補が1つもないということ
は補完する必要がないので、あまりコマンドの主要な動作に影響がないといえばないの
ですが、精神衛生上設定しておくと安心です。[[http://d.hatena.ne.jp/amt/20060806/ZshNoGlob][マッチするパターンがない時のグロブの
動作 -おもてなしの空間]]でこのオプションについて説明があります。man zshoptions
もどうぞ。

あらかじめ候補の数を知るために ls を実行する必要があるので、実行時間的に大丈夫
かな？と思っていました。試しに5000ファイルあるディレクトリで実行してみましたが、
0.5秒程度で絞り込みが始まったので、大概の場合は大丈夫であろうと思います。
Linux であれば。Windows、というか Cygwin だとちょっとつらいかもしれないです。

既知の問題点としては、隠しファイルの ~.~ が付いているファイル群を補完しようと
して ~.~ の上でこのコマンドを実行してもうまく動きません。そのディレクトリにあ
るファイル全てが絞り込みの対象となります。また ~$HOME~ は必ず =~= に置換します
ので、 ~/home/user~ のままにしておくということはできません。 ~ARG~ で場合分け
すればいいんですが、煩雑になりそうだったのでやってません。 ~/home/user~ のまま
にしておきたいという需要はそんなにないですよね？
*** まとめ
空気を読んでファイル名を補完してくれる ~complete-filename-by-percol~ コマンド
を紹介しました。近年 zsh の補完機能にもだいぶ慣れて依存度も高くなっていました
が、補完候補が多いとタブだけで補完するのもめんどくさいなぁ、と思っていまし
た。~complete-filename-by-percol~ を使えばその不満を解消し、高速かつ効率的にファ
イル名を補完できるようになります。

ディレクトリ中のファイル数が多いければ多いほど、このコマンドによる効率アップが
効いてくると思います。使い始めてまだ1週間程度ですが、すでに依存しはじめていま
す。おそらくこのコマンドの恩恵を一番受けるのは、ディレクトリ名に日本語が多用さ
れており、ディレクトリを掘るのがめんどくさい！というような人ではなかろうかと思
います。もし日本語なんかいらね、という人は =--match-method= を regex にすると
いいでしょう。

ぜひぜひ皆さんこのコマンドを使ってみてください。頑張って条件分岐を書きました
が条件の漏れがあるかもしれませんので、こんな時動かんぞー、とかここはこういう
動作にしたほうがいいんじゃないの？などのご意見、ご感想をお待ちしています。

** anything 的絞りこみコマンド percol が migemo 対応しました :percol:zsh:tool:
:PROPERTIES:
:EXPORT_FILE_NAME: 2012-05-12-percol-migemo
:EXPORT_DATE: 2012-05-12
:EXPORT_HUGO_LASTMOD:
:END:

[[./2012-04-29-percol-introduction.org][先日のエントリ]]で [[https://github.com/mooz/percol][percol]] というとっても便利なコマンドを紹介しました。migemo 対
応してくれたら更に便利だなーと思っていたのですが、[[http://d.hatena.ne.jp/mooz/][mooz]] さんがばっちり
~--match-method~ に migemo を追加して下さいました。
{{{more}}}
percol で migemo を使うには [[http://www.kaoriya.net/software/cmigemo][C/Migemo]] と [[http://www.atzm.org/etc/pymigemo.html][PyMigemo]] を導入する必要があります。備忘
として Ubuntu 11.10 とWidnows7 での導入方法を記しておきます。めんどくさいのでイ
ンストール場所は全部デフォルトの場所で、migemo の辞書の文字コードは utf-8 を使
うことにします。

各ソフトウェアのバージョン
- [[http://www.kaoriya.net/software/cmigemo][C/Migemo 1.3]]
- [[http://www.atzm.org/etc/pymigemo.html][PyMigemo 0.3]]
- [[https://github.com/mooz/percol][percol 0.0.2]]
*** Ubuntu 11.04 に導入する
Ubuntu の環境は以下のようになってます。
- Ubuntu 11.10
- python 2.7.2
- zsh 4.3.11

まずは cmigemo の導入です。[[http://www.kaoriya.net/software/cmigemo][KaoriYaさん]]からアーカイブをダウンロードしてきます。
#+BEGIN_EXAMPLE
$ wget http://cmigemo.googlecode.com/files/cmigemo-default-src-20110227.zip
$ unzip cmigemo-default-src-20110227.zip
$ cd cmigemo-default-src
#+END_EXAMPLE
このソースの中の src/wordbuf.c は limits.h をインクルードし忘れているので、以
下のように修正します。
#+BEGIN_EXAMPLE
$ diff -u src/wordbuf.c.bck src/wordbuf.c
--- src/wordbuf.c.bck   2012-05-11 21:52:44.006214700 +0900
+++ src/wordbuf.c       2012-05-11 19:40:39.310948000 +0900
@@ -9,6 +9,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <limits.h>
 #include "wordbuf.h"

 #define WORDLEN_DEF 64
#+END_EXAMPLE
あとはビルドするだけです。
#+BEGIN_EXAMPLE
$ ./configure
$ make gcc
$ make gcc-dict; cd dict; make utf-8; cd ..    # 辞書のビルド
# make gcc-install
#+END_EXAMPLE
これで /usr/local/bin に cmigemo、/usr/local/share/migemo に辞書、
/usr/local/lib に libmigemo.so がインストールされます。

次は PyMigemo を導入します。
#+BEGIN_EXAMPLE
$ wget http://www.atzm.org/etc/files/pymigemo/pymigemo-0.3.tar.gz
$ tar xvf pymigemo-0.3.tar.gz
$ cd pymigemo-0.3
$ python setup.py build
# python setup.py install
#+END_EXAMPLE
これで無事ビルドされるはずです。

最後に percol を入れます。
#+BEGIN_EXAMPLE
$ git clone git://github.com/mooz/percol.git
$ cd percol
# python setup.py install
#+END_EXAMPLE
ビルドはこれだけです。あと設定ファイルが必要ですが、無駄に長くなるので
[[./2012-04-29-percol-introduction.org][前のエントリ]]を見て下さい。
*** Windows7 64bit に導入する
Windows の環境は以下のようになっています。
- Windows7 64bit
- [[http://www.cygwin.com/][Cygwin 1.7.11]]
- python 2.6.7
- zsh 4.3.12

基本的に Cygwin の使用を前提としています。私は Cygwin のもともと全パッケージを
インストールしているので、以下の工程での細かい必要パッケージがわかりません。
cmigemo も Windows用 dll ではなく、ソースからビルドします。

まずは cmigemo ですがすこし make のコマンドが変わるだけです。先程と同様に
src/wordbuf.c の修正は必要です。
#+BEGIN_EXAMPLE
$ wget http://cmigemo.googlecode.com/files/cmigemo-default-src-20110227.zip
$ unzip cmigemo-default-src-20110227.zip
$ cd cmigemo-default-src
$ edit src/wordbuf.c
$ ./configure
$ make cyg
$ make cyg-dict; cd dict; make utf-8; cd ..    # 辞書のビルド
# make cyg-install
#+END_EXAMPLE
これで /usr/local/bin に cmigemo と cygmigemo1.dll、/usr/local/share/migemo に
辞書、/usr/local/lib に libmigemo.dll.a がインストールされます。

次に PyMigemo をビルドします。先程とライブラリの名前が違うので、そのまま
ではビルドできません。
#+BEGIN_EXAMPLE
$ wget http://www.atzm.org/etc/files/pymigemo/pymigemo-0.3.tar.gz
$ tar xvf pymigemo-0.3.tar.gz
$ cd pymigemo-0.3
$ python setup.py build
running build
running build_ext
building 'migemo' extension
（中略）
gcc -shared -Wl,--enable-auto-image-base build/temp.cygwin-1.7.11-i686-2.6/pymigemo.o -L/usr/lib/python2.6/config -lmigemo -lpython2.6 -o build/lib.cygwin-1.7.11-i686-2.6/migemo.dll
/usr/lib/gcc/i686-pc-cygwin/4.5.3/../../../../i686-pc-cygwin/bin/ld: cannot find -lmigemo
collect2: ld returned 1 exit status
error: command 'gcc' failed with exit status 1
#+END_EXAMPLE
setup.py を修正すればいいのかもしれませんが修正の仕方わからなかったので、手動
でlibmigemo.dll.a とリンクしてコンパイルします。
#+BEGIN_EXAMPLE
$ gcc -shared -Wl,--enable-auto-image-base build/temp.cygwin-1.7.11-i686-2.6/pymigemo.o \
  -L/usr/lib/python2.6/config -L/usr/local/lib -lmigemo.dll -lpython2.6 \
  -o build/lib.cygwin-1.7.11-i686-2.6/migemo.dll
# python setup.py install
#+END_EXAMPLE
これでビルド完了です。

percol は先程と全く同じ工程で出来ますので省きます。
*** 使ってみる
実際にしぼり込んでみます。
#+BEGIN_EXAMPLE
$ ls | percol --match-method migemo
#+END_EXAMPLE
[[file:/images/percol_example_migemo.jpg]]

という感じに日本語もばっちり絞り込んでくれます。

[[./2012-04-29-percol-introduction.org][前のエントリ]]で作成した search-document-by-percol はドキュメントを絞り込みます
が、これもばっちり日本語のパスが含まれていても絞り込んでくれるようになりまし
た。1000以上の候補があってもサクサク絞り込んでくれますし、migemo かつ AND 検
索できるようなドキュメント検索ツールは今までにないものだと思います。

zsh の履歴検索もできるかと思ったのですが、日本語を使ったコマンドが .zsh_history
に正しく保存されず文字化けっぽくなってしまいます。どなたか解決策をご存知の方
に教えていただきたい！
*** おわりに
この機能が実装されて本当に便利すぎて滂沱の涙が出てきました。mooz さん本当にあ
りがとうございます。もう拝まずにいられません。ぜひぜひこのエントリを見た人も使っ
てみてください。

** anything 的な絞りこみコマンド percol の紹介              :percol:zsh:tool:
:PROPERTIES:
:EXPORT_FILE_NAME: 2012-04-29-percol-introduction
:EXPORT_DATE: 2012-04-29
:EXPORT_HUGO_LASTMOD:
:END:

いつも [[https://github.com/mooz/keysnail/wiki/keysnail-japanese][KeySnail]] でお世話になっている [[http://d.hatena.ne.jp/mooz/][mooz]] さんが、percol という超絶便利コマ
ンドを作ってらっしゃいます。このコマンドはとてもライフチェンジングなコマンドな
のですが、あまり Web 上に情報がないので紹介がてら布教してみようと思います。

{{{more}}}
*** percol のインストール＆使い方
[[https://github.com/mooz/percol][percol]] は入力の1行を1候補として、部分一致かつ AND 検索で絞り込みし、選択した候
補を出力するコマンドです。端的に言えば Emacs の anything.el のコマンド版です。

インストール方法や基本的な使い方は github リポジトリの README に全部書いてあり
ますが備忘録として書いておきます。
#+BEGIN_EXAMPLE
$ git clone git://github.com/mooz/percol.git
$ cd percol
# python setup.py install
#+END_EXAMPLE
これでインストールは完了です。インストール場所を変えたければ、setup.py に
~--prefix~ オプションをつけます。

percol を動かす前に、percol の設定ファイルが必要です。とりあえず
README からそのままコピーしてきた以下の内容のファイルを、
${HOME}/.percol.d/rc.py に保存します。
#+BEGIN_SRC python
# X / _ / X
percol.view.PROMPT  = ur"<bold><yellow>X / _ / X</yellow></bold> %q"

# Emacs like
percol.import_keymap({
    "C-h" : lambda percol: percol.command.delete_backward_char(),
    "C-d" : lambda percol: percol.command.delete_forward_char(),
    "C-k" : lambda percol: percol.command.kill_end_of_line(),
    "C-y" : lambda percol: percol.command.yank(),
    "C-a" : lambda percol: percol.command.beginning_of_line(),
    "C-e" : lambda percol: percol.command.end_of_line(),
    "C-b" : lambda percol: percol.command.backward_char(),
    "C-f" : lambda percol: percol.command.forward_char(),
    "C-n" : lambda percol: percol.command.select_next(),
    "C-p" : lambda percol: percol.command.select_previous(),
    "C-v" : lambda percol: percol.command.select_next_page(),
    "M-v" : lambda percol: percol.command.select_previous_page(),
    "M-<" : lambda percol: percol.command.select_top(),
    "M->" : lambda percol: percol.command.select_bottom(),
    "C-m" : lambda percol: percol.finish(),
    "C-j" : lambda percol: percol.finish(),
    "C-g" : lambda percol: percol.cancel(),
})
#+END_SRC
このファイルでキーバインドやプロンプトを変えることができるようなので、好みに
合わせて変えてみてください。

percol の簡単な使い方は、行で分割されている出力をパイプで percol に入力します。
例えば
#+BEGIN_EXAMPLE
$ ls / | percol
#+END_EXAMPLE
とすると

[[file:/images/percol_example.jpg]]

このようにルートにあるファイルが候補になります。文字を入力して絞り込んだり、
C-n, C-p で移動して１つの候補を選びます。最後に決定 (Enter, C-m, C-j) を押す
とその候補を標準出力します。
*** 関数を作る
percol は絞り込みするためのコマンドなので、あらかじめある目的の候補群から絞込
みをする関数を作っておくと便利です。典型的な例が README にも書いてある、シェル
の履歴を percol で絞込みする関数です。

まずこの関数を .zshrc に書いておきます。
#+BEGIN_SRC sh
function percol_select_history() {
  local tac_cmd
  which gtac &> /dev/null && tac_cmd=gtac || tac_cmd=tac
  BUFFER=$($tac_cmd ~/.zsh_history | sed 's/^: [0-9]*:[0-9]*;//' \
    | percol --match-method regex --query "$LBUFFER")
  CURSOR=$#BUFFER         # move cursor
  zle -R -c               # refresh
}
zle -N percol_select_history
bindkey '^R' percol_select_history
#+END_SRC
この設定をしてコマンドラインで C-r を押すと

[[file:/images/percol_example_history.jpg]]

このような画面になり、正規表現部分一致かつ AND 検索で過去のコマンド履歴を絞り込
めます。Enter を押すと現在選択中の行のコマンドがコマンドラインに挿入され、そ
のまま実行するなり、一部改変して実行するなりできます。この関数が便利すぎて非
常に泣けてきます。

他にもいくつか関数を自作してみましたので紹介します。

私はドキュメントファイルは特定のディレクトリにおいてあることがほとんどなので、
ディレクトリ中のドキュメントファイルを絞り込んで開く関数を作っています。
#+BEGIN_SRC sh
function search-document-by-percol(){
  DOCUMENT_DIR="\
/path/to/doc/directory1
/path/to/doc/directory2"
  SELECTED_FILE=$(echo $DOCUMENT_DIR | xargs find | \
    grep -E "\.(pdf|txt|odp|odt|ods)$" | percol --match-method regex)
  if [ $? -eq 0 ]; then
    gnome-open $SELECTED_FILE
  fi
}
alias sd='search-document-by-percol'
#+END_SRC
これを .zshrc に書いておきます。この関数を呼び出せば、ドキュメントファイルが列
挙され絞り込むことができます。gnome-open はファイルの拡張子に対応するプログラ
ムを起動するコマンドなので、OS に応じて open なり、cygstart なりに変えてくださ
い。この関数のお陰で（ファイル名やキーワードを覚えてさえいれば）どのファイルに
も5秒程度でアクセスできるようになりました。

次の関数はカレントディレクトリのファイルを絞り込んでプロンプトに挿入します。
#+BEGIN_SRC sh
function insert-file-by-percol(){
  LBUFFER=$LBUFFER$(ls -A | percol --match-method regex | tr '\n' ' ' | \
    sed 's/[[:space:]]*$//') # delete trailing space
  zle -R -c
}
zle -N insert-file-by-percol
bindkey '^[c' insert-file-by-percol
#+END_SRC
これを .zshrc に書いておくと、M-c で絞込みを開始します。カレントディレクトリの
ファイルの補完は当然 zsh の TAB でできます。しかし file001～file100 のように同
じ接頭語のファイルが複数あるディレクトリでファイルを補完する場合には、この関数
のほうが有利かもしれません。マークすることにより同時に複数ファイルを挿入できま
す。
*** まとめ
anything 的な絞りこみコマンド percol の紹介をしました。最近 Emacs でも
anything 脳が着々と進み、そろそろ OS レベルで anything 的なインターフェースを
用意してくれないかなー、と思っていた矢先 percol を見つけたので大変重宝してい
ます。

percol の以前にも同じようなコマンドとして [[https://github.com/zsh-users/zaw][zaw]] や [[http://filmlang.org/soft/canything][canything]] が開発されていまし
た。が、前者は zsh 依存ですし、後者は正規表現や日本語が扱えず少々機能不足です。
その点 percol のいいところは
- python さえあればどこでも動きます。私は基本的には Ubuntu で使っていますが、
  Cygwin on Winodws7 でも普通に動きます。すばらしい。
- アクションで拡張可能。絞込み中に TAB を押すとアクションが選択できます。デフォ
  ルトでは、標準出力する、というアクションしかありませんが、python スクリプト
  を自分で書けばいくらでもアクションを定義できるようです。ユーザの発想次第で
  いくらでも便利に拡張できます。
あたりがあげられるかと思います。

逆に悪い点というか、個人的な要望としては以下の様な点があります。
- percol が起動するのに少々時間がかかります。Ubuntu ではほぼ気になりませんが、
  Cygwin だと0.5秒ほどかかります。許容範囲内ではありますが。
- 一旦マークした後に絞り込み条件を変更するとマークが解除されてしまいます。絞
  り込みを渡り歩きながら複数候補をマークすることができないので、若干不便です。
- +日本語入力はできますが、個人的には migemo れると最高。正規表現との混在はめ
  んどくさいと思うので、--match-method migemo とかあると感涙に咽びなきます。+
  ばっちり migemo 対応して下さいました。[[./2012-05-12-percol-migemo.org][こちら]]も御覧ください。

もし percol に興味を持った方は、github の README をとりあえず真似してみて、
履歴検索の威力をためしてみるといいと思います。

最後に mooz さん、とってもすばらしいコマンドを開発していただきありがとうざいま
す。

** Emacs は外部 elisp がなくても強い (Emacs Advent Calendar jp: 2011 5日目) :Emacs:
:PROPERTIES:
:EXPORT_FILE_NAME: 2011-12-05-emacs-advent-calender-2011-05
:EXPORT_DATE: 2011-12-05
:EXPORT_HUGO_LASTMOD:
:END:

この記事は [[http://atnd.org/events/21982][Emacs Advent Calendar jp: 2011]] の5日目です。 4日目は HKey さんの
[[http://hke7.wordpress.com/2011/12/03/%E3%83%91%E3%82%B9%E3%82%92%E3%81%BE%E3%81%A8%E3%82%81%E3%82%88%E3%81%86-emacs-advent-calendar-jp-2011/][パスをまとめよう]] でした。 6日目は id:kiwanami さんです。kiwanami さんの elisp
にはいつもお世話になっているので、とても楽しみです。

今回は、Emacs に標準で入っているけどあまり知られていなさそうな便利機能、あるい
は数行で書けるカスタマイズや便利コマンドを紹介したいと思います。

紹介するのは以下の機能です。
- 連続 pop-mark
- プレフィックスキーを増やす
- パスを1階層ずつ削除
- 相対的なカーソル位置を動かさないスクロール
について順番に説明していきたいと思います。

{{{more}}}
*** 連続 pop-mark
Emacs のバッファでは、C-SPC あるいは C-@ (`set-mark-command') でカーソルの位置に
マークを付けることができます。このマークとカーソルの間が選択領域になり、その
領域をコピーしたりキルしたりする機能はみんな使っていることと思います。

`set-mark-command' 以外にも `isearch' や `beginning-of-buffer' を実行した際な
どに人知れずマークを変更しているコマンドがあります。これらのコマンドでマークが
変更されるたびに、古いマークは `mark-ring' にスタックのように保存されていきま
す[fn::ちなみに、`isearch' は C-g で検索を終了すると、カーソルが検索を開始する
前の位置に戻りマークは変更されません。C-g 以外の要因で検索が終了した場合のみマー
クが保存されます]。

この `mark-ring'、実は C-u C-SPC (`pop-mark' というコマンドを実行) によって古い
マークを順番に辿っていくことができます。具体的に使い方を見てみましょう。
#+BEGIN_EXAMPLE
|This is a test sentence. `pop-mark' can restore position of cursor.
#+END_EXAMPLE
Emacs のバッファ内に上記のような文章が、ありカーソルが | の位置にあるとします。
ここで C-s ('isearch-forward`) で "sentence" を検索し RET で検索を終了すると
カーソル位置は
#+BEGIN_EXAMPLE
This is a test sentence|. `pop-mark' can restore position of cursor.
#+END_EXAMPLE
このように移動します。この時、`isearch' によって文頭の位置にマークが変更され
ています。さらに "cursor" で検索して RET すると
#+BEGIN_EXAMPLE
This is a test sentence. `pop-mark' can restore position of cursor|.
#+END_EXAMPLE
こうなります。先程と同様に `isearch' によって "sentence" と "." の間にマーク
が変更されています。ここで C-u C-SPC をタイプすると
#+BEGIN_EXAMPLE
This is a test sentence|. `pop-mark' can restore position of cursor.
#+END_EXAMPLE
このようにカーソル位置がマークの位置に戻ります。これが `pop-mark' の機能です。
さらにもう一回 C-u C-SPC をタイプすると
#+BEGIN_EXAMPLE
|This is a test sentence. `pop-mark' can restore position of cursor.
#+END_EXAMPLE
`kill-ring' から1つ前のマークを取り出してきて、その位置にカーソルを移動します。
すなわち最初のカーソル位置に戻ることになります。このようにして、古いマークをど
んどん辿っていくことができます。ソースを見ている際にある関数が使われていて、そ
の関数を `isearch' してその定義の場所まで移動した後また元の場所に戻ってくる、
といったようなことがことがこの機能を使えば簡単に出来ます。

しかし連続でマークを辿る際に C-u C-SPC C-u C-SPC ... を連続で入力するのはめん
どくさい。ので
#+BEGIN_SRC emacs-lisp
;; enable to pop `mark-ring' repeatedly like C-u C-SPC C-SPC ...
(setq set-mark-command-repeat-pop t)
#+END_SRC
この設定を init.el に書いておくと C-u C-SPC C-SPC C-SPC... のように C-SPC を連
続で入力するだけで、連続でマークを辿れるようになります。`pop-mark' は非常に簡
便かつ便利な機能なので、ぜひ使ってみてください。

*** プレフィックスキーを増やす
Emacs をカスタマイズし始め、自分で独自のキーバインドを増やし始めると割り当てる
キーが不足してくるものです。これを解決するには、複数の機能をまとめたコマンドを
使う、キーを増やすような外部 elisp（[[http://www.emacswiki.org/emacs/KeyChord][key-chord.el]] とか）といった対策があると思
います。が、ここではもっと簡単な、いらない1ストロークのキーをプレフィックスキー
にして、2ストロークキーを増やす方法を説明したいと思います。

まず、おそらく一番使用頻度が低いであろう C-q (`quoted-insert') を潰して、プレ
フィックスキーにすることにします。最も単純には、以下のようにすれば2ストローク
キーを定義することができます。
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "C-q") nil)
(define-key global-map (kbd "C-q" "C-q") 'quoted-insert)
(define-key global-map (kbd "C-q" "C-t") 'toggle-truncate-lines)
#+END_SRC
しかしこれは直接2ストロークを指定しているので、プレフィックスキーを C-q から
C-z したいといったことがめんどくさかったりします。そこで自分独自のキーマップを
定義して、そのキーマップをプレフィックスキーに割り当てる方法のほうがなにかと便
利です。その場合はこのようになります。
#+BEGIN_SRC emacs-lisp
(defvar my-original-map (make-sparse-keymap) "My original keymap binded to C-q.")
(define-key global-map (kbd "C-q") my-original-map)
#+END_SRC
新しいキーマップは `make-sparse-keymap' で作成することができるので、それを好き
な名前で定義します。そのキーマップを C-q に割り当てれば C-q がプレフィックスキー
になります。`define-key' の最後の引数はキーマップそのものを指定するのでクオー
トしないことに注意してください。あとは `my-original-map' にコマンドを割り当て
ればどんどん2ストロークキーが増えていきます。

上では、プレフィックスキーに直接キーマップを割り当てましたが、キーマップを呼
び出すための関数を割り当ててもよいです。こんな感じです。
#+BEGIN_SRC emacs-lisp
(defvar my-original-map (make-sparse-keymap) "My original keymap binded to C-q.")
(defalias 'my-original-prefix my-original-map)
(define-key global-map (kbd "C-q") 'my-original-prefix)
#+END_SRC
2行目が加わっただけです。`defalias' で `my-original-prefix' の定義をキーマップ
にします。これで、普通のコマンドのように `define-key' でプレフィックスキーに割
り当てられます[fn::`ctl-x-4-prefix' や `ctl-x-5-prefix' は subr.el でこのようにし
て定義されています]。

2番目と3番目の方法の違いは、`describe-bindings' で表示される名前が変わってき
ます。2番目の場合、C-q は Prefix Command と表記されます。関数が割り当てられて
いないので名前がわからないということでしょう。3番目の方であれば、C-q は
my-original-prefix と表記されることになり、なんのためのプレフィックスかが一目
瞭然となります。どちらを選ぶかは好みになるでしょうか。

また、`define-prefix-command' を使えば `defvar' と `defalias' をひとまとめにす
ることもできます。
#+BEGIN_SRC emacs-lisp
(define-prefix-command 'my-original-map)
(define-key global-map (kbd "C-q") 'my-original-map)
#+END_SRC
キーマップを保持する変数名と、それを呼び出す関数名が同じ `my-original-map' に
なりますが、それが気にならなければこの方法でもいいと思います。しかし、これだと
DOCSTRING が書けないので個人的には3番目の方法で書いています。

自分のオリジナルキーマップの一部を晒してみます。
#+BEGIN_SRC emacs-lisp
;; original key map (bind to C-q)
(defvar my-original-map (make-sparse-keymap)
  "My original keymap binded to C-q.")
(defalias 'my-original-prefix my-original-map)
(define-key global-map (kbd "C-q") 'my-original-prefix)
(define-key my-original-map (kbd "C-q") 'quoted-insert)
(define-key my-original-map (kbd "C-t") 'toggle-truncate-lines)
(define-key my-original-map (kbd "C-l") 'linum-mode)
(define-key my-original-map (kbd "C-r")
  '(lambda () (interactive) (revert-buffer nil t t)))
(define-key my-original-map (kbd "C-c") 'column-highlight-mode)
(define-key my-original-map (kbd "TAB") 'auto-complete) ; あえて手動で補完したい時
#+END_SRC
おおむねトグル系のコマンドや、使用頻度は高くないけどたまーに必要なものを割り当
てています。C-q C-q の `quoted-insert' は特殊文字を入力する際に必要になります。
C-q C-t の `toggle-truncate-lines' はバッファの折り返しをトグル、C-q C-l は行
番号の表示をトグルします。この2つは結構頻繁に切り替えたいので、割り当てておく
と便利です。

C-q C-r は警告なしで `revert-buffer' します。Dropbox で共有したファイルを編集
していると、別の場所で編集したファイルを開きなおすことがあるので割り当てまし
た。最後の2つは外部 elisp の関数です。`column-highlight-mode' はカーソルの
あるカラムをハイライトします。elisp を書く際にインデントが揃っているか確認す
るのに便利です。`auto-complete' は自動的に補完をしてくれる関数ですが、たまに
手動で補完を開始したい時があるので割り当てています。

おまけですが、すでに定義されているキーマップを別のプレフィックスキーに割り当
てることも当然出来ます。
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "C-4") 'ctl-x-4-prefix)
(define-key global-map (kbd "C-5") 'ctl-x-5-prefix)
(defalias 'ctl-x-r-prefix ctl-x-r-map)
(define-key global-map (kbd "S-C-r") 'ctl-x-r-prefix)
#+END_SRC
こうすると、C-x 4 f (`find-file-other-window') や C-x r t
(`string-rectangle') といった長ったらしい3ストロークのキーを2ストロークで入力
できるようになります。特に C-x 4 の other-window 系の関数はが2ストロークで使
えるのは超絶便利です[fn::ただし端末上では C-4 や S-C-r といったキーが使えないの
が残念です]。

*** パスを1階層ずつ削除
`find-file' などでプロンプトにパスを入力する際、現在のディレクトリがプロンプト
にあらかじめ入力されておりカーソルがその右端に置かれている場合が多くあります。

同じディレクトリのファイルを入力する場合はいいのですが、他のディレクトリのファ
イル名を入力したい場合もあり、いちいちパスの階層を BACKSPACE などで削除するの
も手間です。

というわけで、パスを1階層ずつ削除するコマンドを書きました。
#+BEGIN_SRC emacs-lisp
(defun my-minibuffer-delete-parent-directory ()
  "Delete one level of directory path."
  (interactive)
  (let ((current-pt (point)))
    (when (re-search-backward "/[^/]+/?" nil t)
      (forward-char 1)
      (delete-region (point) current-pt))))
(define-key minibuffer-local-map (kbd "M-^") 'my-minibuffer-delete-parent-directory)
#+END_SRC
このコマンドでカーソルの左にある "/" までを削除してくれます。例えば、プロンプ
トで "~/.emacs.d/site-lisp/migemo.el" が入力されている状態で3回コマンドを実行
すると以下のようになります。
#+BEGIN_EXAMPLE
Find File: ~/.emacs.d/site-lisp/migemo.el|
Find File: ~/.emacs.d/site-lisp/|
Find File: ~/.emacs.d/|
Find File: ~/|
#+END_EXAMPLE

短いコマンドですが、効果は上々です。パスが "~/" だけになったときに上の階層にさ
かのぼれないなどの問題はありますが、自分では非常に対症療法な対策しか思いつかな
いので、ハックしてくれる方募集中です。

`minibuffer-local-map' に割り当てればプロンプト中で使うことができます。M-^ に
割り当てたのは、`global-map' で M-^ に割り当てられている `delete-indentation'
とイメージが似てるなーと思ったらからです[fn::この話とは全く関係有りませんが、
`delete-indentation' も便利なコマンドなので使ってみることをお勧めします]。
機能的には <C-backspace> でもイメージしやすいかもしれません。

*** 相対的なカーソル位置を動かさないスクロール
C-v (`scroll-up') をタイプするとバッファ内の画面を上にスクロールさせることがで
きます。この時カーソルはウィンドウの一番上に移動してしまいます。これでは C-v
でバッファ内の目的の場所まで画面をスクロールした後、ウィンドウの一番上から
C-n などで目的の行まで行移動をすることになります。

この挙動は個人的にあまり好みではありませんでした。編集しているときは大概カーソ
ルはウィンドウの真ん中辺りにあるのだから、カーソルはその位置のままスクロールし、
真ん中から細かい行移動をする方が効率的かなーと思いました。Vi/Vim の C-d, C-u が
ちょうどカーソルを動かさずに画面をスクロールします。

Emacs にはそんなコマンドはないようなので、Emacs Lisp の練習がてら自分で書いて
みました。

まず相対的なカーソル位置を保存しないといけないので、
- ウィンドウ内でカーソルが何行目にあるかを取得する関数
が必要になります。またバッファが折り返されている場合、論理行数ではなく物理行数
を数える必要があります。そのためには
- 文字列の幅（カラム数）を返す関数
が必要になります。その2つの関数が以下のようになります。
#+BEGIN_SRC lisp
(defun my-count-lines-window ()
  "Count lines relative to the selected window. The number of line begins 0."
  (interactive)
  (let* ((window-string (buffer-substring-no-properties (window-start) (point)))
         (line-string-list (split-string window-string "\n"))
         (line-count 0)
         line-count-list)
    (setq line-count (1- (length line-string-list)))
    (unless truncate-lines      ; consider folding back
      ;; `line-count-list' is list of the number of physical line which each logical line has.
      (setq line-count-list (mapcar '(lambda (str)
                                       (/ (my-count-string-columns str) (window-width)))
                                    line-string-list))
      (setq line-count (+ line-count (apply '+ line-count-list))))
    line-count))

(defun my-count-string-columns (str)
  "Count columns of string. The number of column begins 0."
  (with-temp-buffer
    (insert str)
    (current-column)))
#+END_SRC
`my-count-lines-window' でカーソル位置がウィンドウ内の何行目かがわかります。折
り返しの境界近くにカーソルがあると1ぐらいずれるかもしれませんが、大体の場合は
大丈夫のはずです。

この2つの関数さえできてしまえば、あとは `scroll-down' がカーソル位置を保つように
アドバイスします。
#+BEGIN_SRC lisp
(defadvice scroll-up (around scroll-up-relative activate)
  "Scroll up relatively without move of cursor."
  (let ((line (my-count-lines-window)))
    ad-do-it
    (move-to-window-line line)))

(defadvice scroll-down (around scroll-down-relative activate)
  "Scroll down relatively without move of cursor."
  (let ((line (my-count-lines-window)))
    ad-do-it
    (move-to-window-line line)))
#+END_SRC
これで、C-v でカーソル移動がしなくなり心持ち負担が減ったように思います。

ついでに、先ほど話しに出した Vi/Vim の C-d, C-u にあたる半画面スクロールや
1行ずつスクロールするキーバインドもあるとたまに便利だったりします。
#+BEGIN_SRC lisp
(define-key global-map (kbd "H-u")
  '(lambda () (interactive) (scroll-down (/ (window-height) 2))))
(define-key global-map (kbd "H-d")
  '(lambda () (interactive) (scroll-up (/ (window-height) 2))))

(define-key global-map (kbd "H-n") '(lambda (arg) (interactive "p") (scroll-up arg)))
(define-key global-map (kbd "H-p") '(lambda (arg) (interactive "p") (scroll-down arg)))
#+END_SRC

このように細かい挙動を自分の好きにカスタマイズできるのが、やはり Emacs の強い
ところだと思います。

** 注文していたサーバー PRIMEGRY TX100 S1 が届いた                   :Server:
:PROPERTIES:
:EXPORT_FILE_NAME: 2011-09-10-primergy-tx100-s1
:EXPORT_DATE: 2011-09-10
:EXPORT_HUGO_LASTMOD:
:END:

*** 低価格静音サーバー PRIMEGRY TX100 S1
前々から自宅サーバを作りたかったのだが、注文していた FUJITSU の [[http://primeserver.fujitsu.com/primergy/products/lineup/tx100s1/][PRIMEGRY
TX100 S1]]（以下TX100）が届いた。TX100 は富士通の静音省電力タワー型のサーバー。
最新のパソコンと比べるとスペックは高くないが、そんなに負荷の高い処理をさせるつ
もりはないので、安いの重視で選んでみた。主なスペックは以下のとおり。

{{{more}}}

- CPU: Intel Pentium E5400 2.7GHz
- メモリ: DDR2 800 UDIMM 1GB（最大8GBまで）
- HDD: 160GB（ベイは4つ）
詳細は [[http://primeserver.fujitsu.com/primergy/products/lineup/tx100s1/tx100s1_catalog.pdf][カタログ]] をみるといいでしょう。

届いた TX100 がこちら。

#+ATTR_HTML: :width 640
[[file:/images/server-photo1.jpg]]

思ったよりも箱がでかい。中身を取り出してみるとこちら。

#+ATTR_HTML: :width 320
[[file:/images/server-photo2.jpg]] [[file:/images/server-photo3.jpg]]

サーバー自体は、タワー型とはいえ、ミドルサイズなのでそこまで邪魔にはならなさそ
う。キーボード、マウスも付いている。なんと、保証書などを入れておくクリアファイ
ルまで付いている行き届きよう。国産っぽいですね。

RAID1構成にするつもりなので、2TBのハードディスクを2つ買っておいた。Western
Digital の [[http://www.amazon.co.jp/gp/product/B005030N36/ref=oss_product][WD20EARX]] です。大容量と安さだけで選びました。

#+ATTR_HTML: :width 320
[[file:/images/server-photo4.jpg]] [[file:/images/server-photo5.jpg]]

サーバーの右側には取っ手がついており、ここを外して中身をいじります。

#+ATTR_HTML: :width 320
[[file:/images/server-photo6.jpg]] [[file:/images/server-photo7.jpg]]

蓋を開けると、パーツがネジ1つのみで固定されていて、ネジは工具なしで手で外すこ
とができます。ネジを外して中を見てみると、配線の取り回しなどはかなり考えられて
おり、工具いらずでハードディスクの入れ替えなどができます。

WD のハードディスク2つをセットして、電源をつけると無事立ち上がり BIOS が起動
しました。

#+ATTR_HTML: :width 640
[[file:/images/server-photo8.jpg]]

静音というだけあって、動作音は全然しない。扇風機（弱）のほうがよっぽどうるさい
です。省電力も期待したいところですが、ワットメーターとかがないので確認しようが
ない。

結局購入したのは
- サーバー: 12,800円
- ハードディスク: 5,580円×2
で、総額23,960円という格安でサーバーが用意できてしまいました。あとはOS のイン
ストールをするだけです。Debian squeeze を使う予定。頑張ってサーバーの構築をし
ていきたいと思います。
*** サーバ構築やらの参考ページ
- [[http://kacho.blog.eonet.jp/blog/2010/06/fujitsu-primerg.html][kacho blog: Fujitsu PRIMERGY TX100 S1 でホームサーバーを作ってみる]]
- [[http://blogs.dion.ne.jp/109nissi/archives/10340115.html][とくみつ録:ホームサーバー導入記（１）～１万円台で購入できる静音PCサーバ
  「 PRIMERGY TX100 S1」でホームサーバーを作ってみました]]
- [[http://weekly.ascii.jp/sp/wsr2f/index.html][Windows Server 2008 R2 Foundation 密着連載]]
- [[http://jouhoujuice.com/blog/2011/07/07/fujitsu-primergy-tx100-s1pgt1016ba-review/][Fujitsu Primergy TX100 S1(PGT1016BA)レビュー | 情報ジュース 情充]]

** キーボード配置を変更する。変態的に。Ubuntu 編          :Ubuntu:mayu:Emacs:
:PROPERTIES:
:EXPORT_FILE_NAME: 2011-04-17-keyboard-config-ubuntu
:EXPORT_DATE: 2011-04-17
:EXPORT_HUGO_LASTMOD:
:END:

[[./2011-04-07-keyboard-config-windows.org][前回の記事]]では Windows 上でどのようにキーボードの配置をカスタマイズしているかを紹介しました．さて，今度は Ubuntu 上で同じキーボードカスタマイズする方法を紹介します．

Windows ではキーボード配置を変更するのに，のどかというアプリケーションを使いましたが，Ubuntu では窓使いの憂鬱を Linux に移植した mayu を使用することにします．

{{{more}}}
*** mayu
窓使いの憂鬱はもともと，UNIX 系から Windows に転職した際に，UNIX 系の操作体系を再現するためのアプリケーションだったはずなのに，今度は Linux 系への逆移植がされて mayu というアプリケーションが開発されるという面白い状態になっています．設定の仕方などは窓使いの憂鬱，のどかとかわらないのがいいですね．

mayu の導入などは他サイトにもあるので，詳しくは書きません．

- [[http://yakinikunotare.boo.jp/orebase/index.php?cmd=read&page=Linux%2FUbuntu%2F%C1%EB%BB%C8%A4%A4%A4%CE%CD%AB%DD%B5%A4%F2%A5%A4%A5%F3%A5%B9%A5%C8%A1%BC%A5%EB][Linux/Ubuntu/窓使いの憂鬱をインストール - 俺の基地]]
- [[http://d.hatena.ne.jp/nokturnalmortum/20090227/1235742723][Ubuntu で窓使いの憂鬱使う方法 - 地獄の猫日記]]

などを参考にどうぞ．詳しい説明は前回やってしまったので，さっさと私の mayu の設定ファイル (.mayu) の内容を示します．

#+BEGIN_EXAMPLE
### .mayu_ubuntu
include "109.mayu" # 109 キーボード設定

keymap Global
## 左コントロールとCapsLockの入れ替え
## CapsLock を Ctrl にして，CapsLock の存在を消し去ることにした
mod Control += Eisuu
key *Eisuu = *LeftControl
#mod Control -= LeftControl
#key LeftControl = Eisuu

## 無変換をAltにする
mod Alt += !!Muhenkan
#key *Muhenkan = *RightAlt
## 単独で押したら ESC にする(one shot modifier)
key ~R-*M-Muhenkan = Escape
key R-*M-Muhenkan = &Ignore

## 変換をCrtlにする．
mod Ctrl += !!Henkan
#key *Henkan = *RightControl
## 単独で押したら ENTER にする(one shot modifier)
key ~R-*C-Henkan = Enter
key R-*C-Henkan = &Ignore

#スペースをshiftとして使用(SandS)
mod Shift += !!!Space
def option delay-of !!! = 2

keymap  KeymapDefault = &Default
#+END_EXAMPLE

以上の設定で，前回説明した caps Lock を ctrl にすることと，shift, ctrl, alt (SandS, one shot modifier) を親指で押せる位置に変更する設定ができます．記述は殆ど変わりません．キーの名前が日本語からアルファベットになっているくらいです．

*** super, hyper の設定
Windows の時と同様に super キーや，hyper キーは mayu では設定できません．そこで，Linux でキーボード配置を変更するプログラムとして定番な xmodmap を使います．xmodmap は割と mayu に似た記法でキーボード配置を変更します（というか窓使いの憂鬱のほうが参考にしたのでしょうね）．

では，カタカナひらがなキーを super キーにします．xmodmap の設定ファイル.Xmodmap（多分ファイル名はなんでもいいはずですが）に以下の設定を書きます．

#+BEGIN_EXAMPLE
!! カタカナひらがなをHyper keyにする
keysym Hiragana_Katakana = Hyper_L
remove mod4 = Hyper_L
add mod3 = Hyper_L
#+END_EXAMPLE

実際にカタカナひらがなキーに hyper を割り当てているのは2行目だけで，他の行はあんまり重要ではありません．この設定ファイルを

#+BEGIN_EXAMPLE
$ xmodmap .Xmodmap
#+END_EXAMPLE

で設定ファイルを読み込むと，設定が有効になります．xmodmap コマンドを単独で使うと現在どのキーに修飾キーが割り当てられているかわかります．

#+BEGIN_EXAMPLE
$ xmodmap
xmodmap:  up to 3 keys per modifier, (keycodes in parentheses):

shift       Shift_L (0x32),  Shift_R (0x3e)
lock        Eisu_toggle (0x42)
control     Control_L (0x25),  Control_R (0x69)
mod1        Alt_L (0x40),  Alt_R (0x6c),  Meta_L (0xcd)
mod2        Num_Lock (0x4d)
mod3        Hyper_L (0x65),  Hyper_L (0xcf)
mod4        Super_L (0x85),  Super_R (0x86),  Super_L (0xce)
mod5        ISO_Level3_Shift (0x5c),  Mode_switch (0xcb)
#+END_EXAMPLE

mod3 に hyper が，mod4 に super が割り当てられているのがわかると思います．Ubuntu ではもともと windows キーに super が割り当てられていたので，xmodmapで設定するまでもありませんでした．この辺は，ディストリビューションやバージョンによって変わってくるかもしれません．

*** おわりに
これで，Windows と Ubuntu でほぼ同じキー配置を使うことができます（厳密に言えばキーボードの入力がどこでトラップされるのかによって細かい動きが変わってくるようですが）．これで Emacs の職業病，左手の小指痛を全く感じずに快適に使うことができます！

** キーボード配置を変更する。変態的に。Windows 編 :Windows:mayu:nodoka:Emacs:
:PROPERTIES:
:EXPORT_FILE_NAME: 2011-04-07-keyboard-config-windows
:EXPORT_DATE: 2011-04-07
:EXPORT_HUGO_LASTMOD:
:END:

実質的な初エントリー。何を書こうかと考えていましたが、ここ数年をかけてカスタマイズを続けていたキーボード配置の変態的カスタマイズをまとめのために紹介しようと思います。使っているキーボードは日本ではごく一般的な109日本語キーボードです。

{{{more}}}
*** そもそもカスタマイズを始めたきっかけ
3年ぐらい前タイピングのスピードをあげるのにはまったことがありました[fn::タイプウェルを練習しまくった]。最初はローマ字入力を練習していたのですがそれが上達してくると、次はアルファベット、記号入力の練習を始めました。アルファベット、記号入力になるとローマ字入力では使わなかった Shift キーを押さなければならなくなります。

このとき、左 Shift キーを左手小指で押していたので、A や Z とかの押しにくさといったらなかった。しかもホームポジションから離れて本来とは違う指で a や z を打鍵しなければいかなくなります。周りには左 Shift キーと右 Shift キーを使い分けている人もいましたが、そんなメンドクセー事はしたくねー、と思いました。ここで初めてキーボード配置を変えたいと思ったわけです。

*** sticky shift, SandS, one shot modifier
んで、そんなことは昔の人達も考えているわけで特殊な Shift キーの入力の仕方は幾つか考えられていました。その1つが [[http://homepage1.nifty.com/blankspace/emacs/sticky.html][sticky Shift]]。これは Shift キーを押しながら他のキーを打鍵するのではなく Shift キーを1回打鍵した直後の文字が大文字になるという入力の仕方です（Shift を押し続ける必要がないということですね）。

そしてもう1つが [[http://pqrs.org/macosx/doc/keyboard/index.html][SandS]] です。これはスペースキーを押しながら他のキーを打鍵するとスペースキーが Shift キーとして働くという入力の仕方です。スペースキーを単独で打鍵すればスペースが入力されます。これは普段遊ばせている親指で Shift キーを押せるようになるので、全くホームポジションから離れずに大文字、記号を入力することができます！初めて使ったときはヨダレが出ました。

この SandS は one shot modifier の一種と言えます。one shot modifier は対象キーをおしながら他のキーを打鍵すると修飾キー[fn::Shift とか Ctrl とか Alt とか]として働き、対象キーを単独で打鍵するとそのまま入力される方式です。SandS の場合は対象キーがスペースで、修飾キーが Shift ということですね。これまたあとで出ます。sticky shift だと1つの大文字しか入力することができません。英語を書いてる時や、SKK で入力するときは便利なんでしょうが、私はプログラムも書くことがあり、大文字、記号が連続することも多々あるので、SandS を使うことにしました。

*** 窓使いの憂鬱
実際に SandS を実現しようとすると、何かしらのプログラムでキー配置をいじることになります。キー配置を変更できるプログラムとしては[[http://mayu.sourceforge.net/][窓使いの憂鬱]]がものすごく有名です。他にも、猫まねきや AutoHotKey とかあるらしいのですが使ったことないので知りません。使っている人がいたら使い勝手を教えてください。

窓使いの憂鬱は

#+BEGIN_QUOTE
いかんともしがたい理由により UN*X Wizard が窓使いにジョブチェンジする時、その操作体系の違いにより憂鬱な日々を送らざるを得ないことは想像に難くありません。「窓使いの憂鬱」は、その憂鬱を少しだけ和らげることができるアイテムです。 --- [[http://mayu.sourceforge.net/][窓使いの憂鬱]]
#+END_QUOTE

というような目的で作られており、かなーり柔軟にキーボード配置の変更ができます。詳細はマニュアルに譲りますが、SandS を使うだけなら設定ファイルに

#+BEGIN_EXAMPLE
mod Shift += !!Space
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
mod Shift += !!!Space
#+END_EXAMPLE

と書くだけです。前者の場合、スペースを押し続けても、スペースは入力されません。これだと、連続してスペースを入力したいとき不便なので、後者の場合はスペースを押し続けてしばらく経つとスペースが（連続で）入力されます。スペースを押してからどのキーを打鍵しようかな？と考えているとスペースが入力されてしまいます。そんなこんなで SandS を手に入れた私は超快適な Shift 生活を送ることができました。

*** Ctrl キーのカスタマイズ
タイピングにはまっていたのとほぼ同じ頃、私は Emacs というエディタを使い始めました。一般的な Windows ユーザは Shift やせいぜい Ctrl ぐらいしか修飾キーを使わないと思いますが、このEmacs というエディタ、Ctrl や Alt、果てには Super やHyper といった修飾キーを多用しまくります。特に Ctrl キーの使う頻度は半端じゃありません。というか使わないとまともに操作できません。

なので、Emacs 界隈ではキーボードの左下に追いやられている左 Ctrl を Caps Lockと交換して、a キーの横に Ctrl を持ってくることがよくやられます。はじめからそう配置されているキーボードがあるくらいですから、やっている人はかなり多いのでしょう。これを窓使いの憂鬱で実現するには、設定ファイルに

#+BEGIN_EXAMPLE
## 左コントロールとCapsLockの入れ替え
## CapsLock を Ctrl にして、CapsLock の存在を消し去ることにした
mod Control += 英数
key *英数 = *LeftControl
#mod Control -= LeftControl
#key LeftControl = 英数
#+END_EXAMPLE

と書きます[fn::＃から改行まではコメントです]。下2行がコメントアウトしてありますが、これは私の場合は Ctrl と Caps Lock の交換ではなく Caps Lock を Ctrl に変更して Caps Lock というキーには消え去ってもらうことにしています。いままで一度も意図的に Caps Lock を使ったことはありませんし、他人に Ctrl どこにあるの？と聞かれる心配もないので、これでいいかと思っています。下2行のコメントアウトを外せば単純な交換になります。このカスタマイズによってだいぶ Emacs が使いやすくなります。

*** さらにカスタマイズ。親指を遊ばせてはならない
以上で SandS と Ctrl の位置変更はできて、なかなか使い勝手も向上したわけですが、まだ満足しません。まず、Crtl が a キーの横になったのはいいのですが、これは結局左手小指で押さなければならず、左 Shift キーと同じ問題がでてきます（Ctrl+a をどうやって押すか？）。また、Emacs でなかなか使用頻度の高い Alt の押しにくさも問題です（最も使うであろう Alt+x は親指がつりそうになります）。

じゃあどうするかというと、ここまで読んでくれたなら予想できてしまうかもしれませんが、Ctrl も Alt も親指で押せる位置に変更します。当然親指の位置的にスペースキーに近いキーになります。そして、スペースの両隣といえば変換キーと無変換キー。みなさん、この2つのキー使ったことありますか？私はありません。なんでこんな位置に鎮座しているのか全く理解できませんが、この位置にあるなら有効活用してしまおうということです。

ちなみにこの頃から使う OS が Windows 7 になり、窓使いの憂鬱が開発終了で使えなくなってしまいました。Windows 7 における窓使いの憂鬱の後継として[[http://www.appletkan.com/nodoka.htm][のどか]]というプログラムがあります。有料にはなってしまいましたが2000円程度ですし、それだけの価値は絶対あります、とおすすめしておきます。以下ではのどかの設定を説明します。使い勝手はほぼ窓使いの憂鬱とは変わりませんから、以下の設定も窓使いの憂鬱でそのまま使えるかもしれません（確認はしていない）。

というわけでのどかで変換キーに Ctrl、無変換キーに Alt を割り当てるには、のどかの設定ファイルに

#+BEGIN_EXAMPLE
## 無変換をAltにする
mod Alt += !!無変換
key *無変換 = *RightAlt
## 変換をCrtlにする
mod Ctrl += !!変換
key *変換 = *RightControl
#+END_EXAMPLE

と書くだけです。実に簡単です。ただし、もともと IME で変換キーや無変換キーに何かしらの動作が割り当てられていることがあります。それを無効にしないと所望の動きはしないと思います。

このカスタマイズをすることにより Emacs の操作性は当社比2倍になります。実際、これによって Alt を使うキーバインドが使いやすくなり、ますます Emacs が便利になった気がします[fn::以前は M-% なんて両手で押してましたが、今は左手の親指と人差指だけでおせます]。親指を使うのは最初はなかなか難しいですが、慣れればそうでもありません。動きとしては圧倒的に人差し指から小指までのほうが激しいのですから。

*** さらにさらに（変態的に）カスタマイズ。修飾キーだけなんてもったいない
実は上の Ctrl や Alt を親指で押すのは、Emacs 界隈ではたまに聞く話で、私以外にも設定している人はいると思います。しかし、私はこれをさらに変態的にカスタマイズします。せっかく親指で修飾キーを押せるようになったのだから、その修飾キーをone shot modifier にしてしまうのです。つまり、変換キーや無変換キーを単独で打鍵した場合、何か別のキーを入力するように設定します。

どのキーを入力するかはいろいろ考えられます。私も試行錯誤中ですが、今のところ変換キーを Enter、無変換キーを Esc にしています。この2つのキーは意外とホームポジションから遠いのです。Emacs 使いなら Enter は C-m にしろ、と言われるかもしれませんが、C-m は1ストロークとはいえ2つのキーを押すことになるので、やはり1つのキー単独の押しやすさにはかないませんし、のどかで設定すればどのようなアプリケーション上でも使えるので便利です。Esc は Emacs ではそんなに使用頻度は高くありませんが、あると便利なときもあります。vi 派の人ならものすごく便利に使えるんじゃないでしょうか？

これを実現するのどかの設定は

#+BEGIN_EXAMPLE -n
## 変換をCrtlにする
mod Ctrl += !!変換
#key *変換 = *RightControl
## 単独で押したら Enter にする(one shot modifier)
key ~R-*C-変換 = Enter
key R-*C-変換 = &Ignore

## 無変換をAltにする
mod Alt += !!無変換
#key *無変換 = *RightAlt
## 単独で押したら Esc にする(one shot modifier)
key ~R-*M-無変換 = Escape
key R-*M-無変換 = &Ignore

## Emacs でうまく動いてくれないの対策
## IME の状態を無視するために必要？
key *IC-*I- =
#+END_EXAMPLE

となります。この設定で、変換キーと無変換キーを one shot modifier にすることができます。単独で押すキーを設定しているのが5, 12行目です。それだけだと、Ctrl+何かのキー を押そうとして変換キーを押したけど、やっぱやめた、と思って変換キーを離すと Enter が入力されてしまいます。&Ignore がある行でそれを防止しています。最後の1行は Emacs でうまく動いてくれないのを防止するための設定です。詳しくは[[http://sourceforge.jp/ticket/browse.php?group_id=3682&tid=24450][ここ]]を見てみてください。

ここまで変態的なキー配置にしている人はあまりいないんじゃないでしょうか。使ってみると Enter の押しやすさにはかなりびっくりします。

*** 私は病気です。わかってます。でも hyper と super が必要なんです。
ここからは Emacs 限定です。先程も少し言ったように、Emacs では ctrl や alt の他にも hyper や super という修飾キーが使えます。聞きなれない修飾キーですが、昔のキーボードにはあったらしいのです。Emacs では ctrl や alt を使ったキーバインドは多いので、なかなか自由にキーバインドを変更できませんが、hyper や super を使ったキーバインドは自分の好きに割り当てることができます。私の場合、実際にはそんなに多く割り当てていませんが、将来キーバインドが増えることを考慮して hyper, super を用意しています。

しかし、のどかでは hyper, super という修飾キーを直接何かのキーに割り当てることはできません。もし出来る方法をご存じの方がいましたら、教えてくれるとうれしいです。

じゃあどうするかというと、Windwos 上の Emacs であれば、Emacs の設定によりwindows キーと app キーを hyper, super にすることができます。しかし、大概のキーボードでは、app キーは押しにくいところにあるものです。なので、のどかで位置の変更をしておきます。当然親指で押せるところです。ここでは、変換の1つ右隣、これまた使ったことのないカタカナひらがなキーを app キーとして使います。のどかの設定で

#+BEGIN_EXAMPLE
## ひらがなキーを Applications キーにする
## Emacs で hyper としてつかうため
key *ひらがな = *Applications
#+END_EXAMPLE
と書くだけです。実質1行です。あとは、Emacs の方で設定するだけです。Emacs の設
定ファイル(init.el)に
#+BEGIN_SRC emacs-lisp
(setq w32-apps-modifier 'hyper      ; apps キーを hyper キーにする
      w32-lwindow-modifier 'super)  ; 左Windows キーを super キーにする
#+END_SRC

と書けば OK。これで自由に hyper と super が使えます。ただし、もともと OS で設定されている windows+d や windos+e を Emacs で使うのは難しいと思います。他のキーバインドにしときましょう。

さらに、windows キーももっと親指で押しやすい位置に変更することも考えました。本来左 alt のある場所に割り当てるとか。しかし、そうすると普通だと使うであろう左alt が潰れてしまいます。他の人がこのキーボード配置で使ったときに混乱してしまう可能性があります。というわけで、今はその設定は見送っています。

実は今までの設定は、普段殆ど使わないキーに対して新しいキーを割り当てていただけなので、他の人が使ったとしてもほとんど違和感を感じないはずです。それは逆に言うと自分が他の普通のキーボードを使うときもキーの押し間違えをすることも少なくなると思います（効率は当然落ちますが）。つまり、このキーボード配置への依存度を下げることができるのです（今更の感は多分にありますが）！

*** まとめ
以上つらつらと書きましたが、現在のキー配置をまとめて図で表すとこのようになっています。

[[file:/images/keyboard.png]]

とにかく、親指修飾キーは超おすすめですので一度やってみてください！みんな親指を遊ばせすぎです。ctrl や alt は標準でこの位置にしてもいいくらいだと思うんですけどね。

この記事は Windows 上での話です。Ubuntu でも同じようなキーボード配置にしているのですが、記事が長くなりすぎたのでその解説は次回ということで。長文失礼しました。

*** おまけ
使っているキーボードはスペースバーの長さが普通のキー2つ分くらいです。4つ分くらいの長いスペースバーだと変換キーや無変換キーが押しにくく、親指修飾キーの威力が半減します。ぜひ短いスペースバーのキーボードでどうぞ。私はスペースバーの長さで買うノートパソコンを決めたぐらいです。
